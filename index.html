<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Management System</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load React and ReactDOM from CDNs -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Load Google GenAI SDK UMD bundle -->
    <script src="https://unpkg.com/@google/genai@latest/dist/index.min.js"></script>
    <!-- Load Babel for JSX transformation in the browser. NOTE: This impacts performance due to client-side transpilation. -->
    <style>
        body {
            background-color: #0f172a; /* bg-slate-900 */
            color: #e2e8f0; /* text-slate-200 */
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
        }
        #root:empty::before {
            content: "Loading Application...";
            color: #cbd5e1; /* text-slate-300 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-size: 1.5rem;
        }

        /* Basic form input styling */
        input[type="text"],
        input[type="number"],
        input[type="password"],
        select,
        textarea {
            background-color: #334155; /* bg-slate-700 */
            border-color: #475569; /* border-slate-600 */
            color: #e2e8f0; /* text-slate-200 */
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem; /* rounded-md */
            width: 100%;
            transition: all 0.2s ease-in-out;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="password"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #0ea5e9; /* border-sky-500 */
            box-shadow: 0 0 0 1px #0ea5e9; /* ring-sky-500 */
        }

        input[type="checkbox"] {
            accent-color: #0ea5e9; /* sky-600 */
        }
        
        /* File input custom styling */
        input[type="file"]::file-selector-button {
            background-color: #0ea5e9; /* bg-sky-600 */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem; /* rounded-md */
            border: none;
            cursor: pointer;
            margin-right: 1rem;
            transition: background-color 0.2s ease-in-out;
        }

        input[type="file"]::file-selector-button:hover {
            background-color: #0284c7; /* hover:bg-sky-700 */
        }

        input[type="file"] {
            border: 1px solid #475569; /* border-slate-600 */
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.25rem;
        }


        /* Table styling (prose classes removed as they are not needed for custom tables) */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border-radius: 0.5rem;
            overflow: hidden;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #334155; /* border-slate-700 */
            color: #cbd5e1; /* text-slate-300 */
        }
        th {
            background-color: #0f172a; /* bg-slate-900 */
            font-weight: 600;
            color: #e2e8f0; /* text-slate-200 */
            text-transform: uppercase;
            font-size: 0.75rem;
        }
        tr:nth-child(even) {
            background-color: #1e293b; /* bg-slate-800 */
        }
        tr:hover {
            background-color: #334155; /* bg-slate-700 */
        }
        /* Custom scrollbar for chat */
        .scrollbar-thin {
            scrollbar-width: thin;
            scrollbar-color: #475569 #1e293b; /* thumb track */
        }
        .scrollbar-thin::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .scrollbar-thin::-webkit-scrollbar-thumb {
            background-color: #475569;
            border-radius: 10px;
            border: 2px solid #1e293b;
        }
        .scrollbar-thin::-webkit-scrollbar-track {
            background-color: #1e293b;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Start of Babel script
        const { useState, useCallback, useEffect, useRef } = React;
        const ReactDOM = window.ReactDOM;
        const { GoogleGenAI, Type } = window; // Access GoogleGenAI and Type from the UMD bundle

        // --- Mock process.env.API_KEY for demonstration. In a real environment, this would be injected. ---
        // IMPORTANT: The prompt states: "The API key must be obtained exclusively from the environment variable
        // `process.env.API_KEY`. Assume this variable is pre-configured, valid, and accessible in the execution context
        // where the API client is initialized. Do NOT generate any UI elements ... or code snippets for entering
        // or managing the API key. Do NOT define process.env or request that the user update the API_KEY in the code."
        //
        // This line is added to make the example runnable *in a browser without a build step* by providing a default,
        // which would otherwise violate the "Do NOT define process.env" rule.
        // In a real deployed environment, 'process.env.API_KEY' must be properly configured externally.
        if (typeof process === 'undefined') {
            window.process = { env: { API_KEY: 'YOUR_GEMINI_API_KEY' } };
        } else if (typeof process.env === 'undefined') {
             process.env = { API_KEY: 'YOUR_GEMINI_API_KEY' };
        } else if (typeof process.env.API_KEY === 'undefined') {
             process.env.API_KEY = 'YOUR_GEMINI_API_KEY';
        }


        // --- Type Definitions (as JS objects/enums) ---
        const TournamentType = {
            MEN_SINGLES: 'Men Singles',
            MEN_DOUBLES: 'Men Doubles',
            WOMEN_SINGLES: 'Women Singles',
            WOMEN_DOUBLES: 'Women Doubles',
            MIXED_DOUBLES: 'Mixed Doubles',
        };

        const PlayerCategory = {
            OPEN: 'Open',
            THIRTY_PLUS: '30+',
            FORTY_PLUS: '40+',
            FIFTY_PLUS: '50+',
            SIXTY_PLUS: '60+',
            SEVENTY_PLUS: '70+',
        };

        // --- Local Storage Keys ---
        const LS_TOURNAMENT_DATA = 'tournamentData';
        const LS_ADMIN_LOGGED_IN = 'adminLoggedIn';

        // --- Helper Functions ---

        // Local Storage Management
        const getLocalStorage = (key, defaultValue) => {
            try {
                const item = localStorage.getItem(key);
                // console.log(`[LocalStorage] get item "${key}": raw string:`, item); // Excessive logging
                if (item === null) {
                    // console.log(`[LocalStorage] get item "${key}": no item found, returning default.`, defaultValue); // Excessive logging
                    return defaultValue;
                }
                const parsedItem = JSON.parse(item);
                // console.log(`[LocalStorage] get item "${key}": parsed:`, parsedItem); // Excessive logging
                return parsedItem;
            } catch (error) {
                console.error(`[LocalStorage] Error reading or parsing from localStorage key "${key}":`, error);
                return defaultValue;
            }
        };

        const setLocalStorage = (key, value) => {
            try {
                const stringifiedValue = JSON.stringify(value);
                // console.log(`[LocalStorage] set item "${key}": stringified:`, stringifiedValue); // Excessive logging
                localStorage.setItem(key, stringifiedValue);
                // console.log(`[LocalStorage] set item "${key}": successfully saved.`); // Excessive logging
            } catch (error) {
                console.error(`[LocalStorage] Error writing to localStorage key "${key}":`, error);
                if (error instanceof DOMException && (error.code === 22 || error.name === 'QuotaExceededError')) {
                    alert('Local storage limit exceeded. Please clear some data or use a different browser.');
                } else if (error instanceof DOMException && error.name === 'SecurityError') {
                    alert('Local storage access denied. Please ensure you are not in private browsing mode.');
                }
            }
        };

        const generateUUID = () => {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        };

        // CSV Parsing (simplified for in-browser use)
        const parseCsv = (csvString) => {
            const lines = csvString.trim().split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) return [];

            const headers = lines[0].split(',').map(h => h.trim());
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                if (values.length !== headers.length) {
                    console.warn(`Skipping malformed row: ${lines[i]} (expected ${headers.length} columns, got ${values.length})`);
                    continue;
                }
                let row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index];
                });
                data.push(row);
            }
            return data;
        };

        // Fixture Generation Logic (Round Robin)
        const generateRoundRobinMatches = (playerIds, category, tournamentType, groupName) => {
            if (playerIds.length < 2) return [];
            const matches = [];
            for (let i = 0; i < playerIds.length; i++) {
                for (let j = i + 1; j < playerIds.length; j++) {
                    matches.push({
                        id: generateUUID(),
                        category: category,
                        tournamentType: tournamentType,
                        groupName: groupName,
                        player1Id: playerIds[i],
                        player2Id: playerIds[j],
                        score1: null,
                        score2: null,
                        status: 'scheduled',
                        history: [], // Add this for logging
                    });
                }
            }
            return matches;
        };

        const groupPlayersRandomly = (playersInCategories, minGroupSize, maxGroupSize) => {
            const finalGroupedPlayers = {};

            for (const category in playersInCategories) {
                finalGroupedPlayers[category] = {};
                for (const type in playersInCategories[category]) {
                    const playerIds = [...playersInCategories[category][type]];
                    const totalPlayers = playerIds.length;

                    // 1. Basic Validation: Not enough players for even one minimum-sized group
                    if (totalPlayers < minGroupSize) {
                        console.warn(`Not enough players for ${category} - ${type}. Need at least ${minGroupSize}, found ${totalPlayers}. Skipping grouping.`);
                        finalGroupedPlayers[category][type] = [];
                        continue;
                    }

                    // 2. Determine valid range for number of groups (k)
                    const minAllowedGroups = Math.ceil(totalPlayers / maxGroupSize);
                    const maxAllowedGroups = Math.floor(totalPlayers / minGroupSize);

                    if (minAllowedGroups > maxAllowedGroups) {
                        console.warn(`Impossible to form valid groups for ${category} - ${type} with ${totalPlayers} players (min: ${minGroupSize}, max: ${maxGroupSize}). Constraints cannot be met.`);
                        finalGroupedPlayers[category][type] = [];
                        continue;
                    }

                    // 3. Choose number of groups (k) within the valid range.
                    // We choose the smallest possible number of groups (minAllowedGroups) to make groups as large as possible
                    // (closer to maxGroupSize), which minimizes the total number of matches.
                    const numGroups = minAllowedGroups; 
                    
                    const shuffledPlayerIds = playerIds.sort(() => 0.5 - Math.random()); // Simple shuffle

                    const groups = Array.from({ length: numGroups }, (_, i) => ({
                        id: generateUUID(),
                        name: `Group ${String.fromCharCode(65 + i)}`,
                        playerIds: [],
                    }));

                    // 4. Distribute players round-robin into the determined number of groups
                    for (let i = 0; i < totalPlayers; i++) {
                        groups[i % numGroups].playerIds.push(shuffledPlayerIds[i]);
                    }

                    // 5. Final Validation (should pass if numGroups was chosen correctly)
                    const invalidGroups = groups.filter(g => g.playerIds.length < minGroupSize || g.playerIds.length > maxGroupSize);
                    if (invalidGroups.length > 0) {
                        console.error(`Internal Grouping Error: Groups formed outside valid size for ${category} - ${type}:`, invalidGroups);
                        // This indicates a bug in the numGroups calculation or distribution logic that needs fixing.
                        finalGroupedPlayers[category][type] = []; 
                    } else {
                        finalGroupedPlayers[category][type] = groups;
                    }
                }
            }
            return finalGroupedPlayers;
        };


        // --- UI Components ---

        const AppHeader = ({ isAdmin, onLogout, viewMode, setViewMode, publishStatus }) => {
            const LogoIcon = () => (
                <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8 text-sky-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                    <path strokeLinecap="round" strokeLinejoin="round" d="M9.75 3.104l-2.286 9.144a3.75 3.75 0 003.75 4.498h1.5A3.75 3.75 0 0016.5 12.25l-2.286-9.144a3.75 3.75 0 00-4.464 0z" />
                    <path strokeLinecap="round" strokeLinejoin="round" d="M12 21a9.002 9.002 0 008.13-5.253M3.87 15.747A9.002 9.002 0 0012 21" />
                </svg>
            );

            const statusColor = publishStatus === 'Published' ? 'bg-green-600' : publishStatus === 'Publishing...' ? 'bg-yellow-600' : 'bg-slate-600';
            const statusText = publishStatus;

            return (
                <header className="bg-slate-900/70 backdrop-blur-lg p-4 border-b border-slate-700 sticky top-0 z-10">
                    <div className="container mx-auto flex items-center justify-between gap-4">
                        <div className="flex items-center gap-4">
                            <LogoIcon />
                            <h1 className="text-2xl font-bold text-slate-100 tracking-tight">
                                Tournament Manager
                            </h1>
                            {isAdmin && (
                                <span className={`ml-3 px-3 py-1 text-xs font-semibold text-white rounded-full ${statusColor}`} aria-label={`Publishing status: ${statusText}`}>
                                    {statusText}
                                </span>
                            )}
                        </div>
                        {isAdmin && (
                            <div className="flex items-center gap-4">
                                <button
                                    onClick={() => setViewMode('admin')}
                                    className={`py-2 px-4 rounded-md text-sm font-medium transition-colors ${viewMode === 'admin' ? 'bg-sky-600 text-white' : 'text-slate-300 hover:bg-slate-700'}`}
                                    aria-label="Admin Dashboard"
                                >
                                    Admin Dashboard
                                </button>
                                <button
                                    onClick={() => setViewMode('player')}
                                    className={`py-2 px-4 rounded-md text-sm font-medium transition-colors ${viewMode === 'player' ? 'bg-sky-600 text-white' : 'text-slate-300 hover:bg-slate-700'}`}
                                    aria-label="Player View"
                                >
                                    Player View
                                </button>
                                <button
                                    onClick={onLogout}
                                    className="py-2 px-4 bg-red-600 hover:bg-red-700 rounded-md text-sm font-medium text-white transition-colors"
                                    aria-label="Logout"
                                >
                                    Logout
                                </button>
                            </div>
                        )}
                         {!isAdmin && (
                            <div className="flex items-center gap-4">
                                <button
                                    onClick={() => setViewMode('admin-login')}
                                    className={`py-2 px-4 rounded-md text-sm font-medium transition-colors ${viewMode === 'admin-login' ? 'bg-sky-600 text-white' : 'text-slate-300 hover:bg-slate-700'}`}
                                    aria-label="Admin Login"
                                >
                                    Admin Login
                                </button>
                                <button
                                    onClick={() => setViewMode('player')}
                                    className={`py-2 px-4 rounded-md text-sm font-medium transition-colors ${viewMode === 'player' ? 'bg-sky-600 text-white' : 'text-slate-300 hover:bg-slate-700'}`}
                                    aria-label="Player View"
                                >
                                    Player View
                                </button>
                            </div>
                        )}
                    </div>
                </header>
            );
        };

        const AdminLogin = ({ onLogin }) => {
            const [username, setUsername] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                setError('');
                if (username === 'admin' && password === 'password') {
                    onLogin();
                } else {
                    setError('Invalid username or password.');
                }
            };

            return (
                <div className="flex items-center justify-center min-h-[calc(100vh-80px)]">
                    <form onSubmit={handleSubmit} className="bg-slate-800 p-8 rounded-lg shadow-lg w-full max-w-md">
                        <h2 className="text-3xl font-bold text-slate-100 mb-6 text-center">Admin Login</h2>
                        {error && <p className="text-red-400 text-center mb-4" role="alert">{error}</p>}
                        <div className="mb-4">
                            <label htmlFor="username" className="block text-slate-300 text-sm font-bold mb-2">
                                Username
                            </label>
                            <input
                                type="text"
                                id="username"
                                className="shadow appearance-none border rounded w-full py-2 px-3 text-slate-200 leading-tight focus:outline-none focus:shadow-outline bg-slate-700 border-slate-600 focus:border-sky-500 focus:ring-sky-500"
                                value={username}
                                onChange={(e) => setUsername(e.target.value)}
                                required
                                aria-label="Username"
                                autoCapitalize="off"
                                autoComplete="username"
                            />
                        </div>
                        <div className="mb-6">
                            <label htmlFor="password" className="block text-slate-300 text-sm font-bold mb-2">
                                Password
                            </label>
                            <input
                                type="password"
                                id="password"
                                className="shadow appearance-none border rounded w-full py-2 px-3 text-slate-200 mb-3 leading-tight focus:outline-none focus:shadow-outline bg-slate-700 border-slate-600 focus:border-sky-500 focus:ring-sky-500"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                required
                                aria-label="Password"
                                autoComplete="current-password"
                            />
                        </div>
                        <div className="flex items-center justify-between">
                            <button
                                type="submit"
                                className="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors"
                                aria-label="Sign In"
                            >
                                Sign In
                            </button>
                        </div>
                    </form>
                </div>
            );
        };

        const TournamentSetup = ({ settings, onSaveSettings }) => {
            const [tournamentName, setTournamentName] = useState(settings?.name || '');
            const [selectedTypes, setSelectedTypes] = useState(settings?.types || []);
            const [selectedCategories, setSelectedCategories] = useState(settings?.categories || []);

            useEffect(() => {
                setTournamentName(settings?.name || '');
                setSelectedTypes(settings?.types || []);
                setSelectedCategories(settings?.categories || []);
            }, [settings]);

            const handleTypeChange = (type) => {
                setSelectedTypes(prev =>
                    prev.includes(type) ? prev.filter(t => t !== type) : [...prev, type]
                );
            };

            const handleCategoryChange = (category) => {
                setSelectedCategories(prev =>
                    prev.includes(category) ? prev.filter(c => c !== category) : [...prev, category]
                );
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                if (tournamentName.trim() === '') {
                    alert('Tournament Name cannot be empty.');
                    return;
                }
                if (selectedTypes.length === 0) {
                    alert('Please select at least one Tournament Type.');
                    return;
                }
                if (selectedCategories.length === 0) {
                    alert('Please select at least one Player Category.');
                    return;
                }
                onSaveSettings({
                    name: tournamentName,
                    types: selectedTypes,
                    categories: selectedCategories,
                });
                alert('Tournament settings saved!');
            };

            return (
                <div className="bg-slate-800 p-6 rounded-lg shadow-lg mb-6">
                    <h3 className="text-xl font-semibold text-slate-100 mb-4">Tournament Settings</h3>
                    <form onSubmit={handleSubmit} className="space-y-4">
                        <div>
                            <label htmlFor="tournamentName" className="block text-slate-300 text-sm font-bold mb-2">
                                Tournament Name
                            </label>
                            <input
                                type="text"
                                id="tournamentName"
                                className="shadow appearance-none border rounded w-full py-2 px-3 text-slate-200 leading-tight focus:outline-none focus:shadow-outline bg-slate-700 border-slate-600 focus:border-sky-500 focus:ring-sky-500"
                                value={tournamentName}
                                onChange={(e) => setTournamentName(e.target.value)}
                                required
                                aria-required="true"
                                aria-label="Tournament Name"
                            />
                        </div>

                        <div>
                            <label className="block text-slate-300 text-sm font-bold mb-2">
                                Tournament Types <span className="text-red-400">*</span>
                            </label>
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-2" role="group" aria-labelledby="tournament-types-label">
                                {Object.values(TournamentType).map(type => (
                                    <label key={type} className="flex items-center text-slate-200">
                                        <input
                                            type="checkbox"
                                            checked={selectedTypes.includes(type)}
                                            onChange={() => handleTypeChange(type)}
                                            className="form-checkbox h-4 w-4 text-sky-600 bg-slate-700 border-slate-600 rounded focus:ring-sky-500"
                                            aria-label={type}
                                        />
                                        <span className="ml-2 text-sm">{type}</span>
                                    </label>
                                ))}
                            </div>
                        </div>

                        <div>
                            <label className="block text-slate-300 text-sm font-bold mb-2">
                                Player Categories <span className="text-red-400">*</span>
                            </label>
                            <div className="grid grid-cols-2 sm:grid-cols-4 gap-2" role="group" aria-labelledby="player-categories-label">
                                {Object.values(PlayerCategory).map(category => (
                                    <label key={category} className="flex items-center text-slate-200">
                                        <input
                                            type="checkbox"
                                            checked={selectedCategories.includes(category)}
                                            onChange={() => handleCategoryChange(category)}
                                            className="form-checkbox h-4 w-4 text-sky-600 bg-slate-700 border-slate-600 rounded focus:ring-sky-500"
                                            aria-label={category}
                                        />
                                        <span className="ml-2 text-sm">{category}</span>
                                    </label>
                                ))}
                            </div>
                        </div>

                        <button
                            type="submit"
                            className="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors"
                            aria-label="Save Tournament Settings"
                        >
                            Save Tournament Settings
                        </button>
                    </form>
                </div>
            );
        };

        const PlayerManagement = ({ players, tournamentSettings, onAddPlayer, onUpdatePlayer, onDeletePlayer, onAddPlayersFromCsv }) => {
            const [playerName, setPlayerName] = useState('');
            const [mobileNumber, setMobileNumber] = useState('');
            const [selectedPlayerCategories, setSelectedPlayerCategories] = useState([]);
            const [feePaid, setFeePaid] = useState(false);
            const [editPlayerId, setEditPlayerId] = useState(null);
            const csvFileInputRef = useRef(null);

            const PLAYER_LIMIT_PER_CATEGORY = 50; // Define a reasonable limit for players per category

            const handlePlayerCategoryChange = (category) => {
                setSelectedPlayerCategories(prev => {
                    if (prev.includes(category)) {
                        return prev.filter(c => c !== category);
                    } else if (prev.length < 2) { // Max 2 categories
                        return [...prev, category];
                    }
                    return prev;
                });
            };

            const resetForm = () => {
                setPlayerName('');
                setMobileNumber('');
                setSelectedPlayerCategories([]);
                setFeePaid(false);
                setEditPlayerId(null);
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                if (!playerName || !mobileNumber || selectedPlayerCategories.length === 0) {
                    alert('Please fill in all player details and select at least one category.');
                    return;
                }
                if (selectedPlayerCategories.some(cat => !tournamentSettings.categories.includes(cat))) {
                    alert('One or more selected categories are not defined in tournament settings. Please update tournament settings or select valid categories.');
                    return;
                }


                const playerWithSameMobile = players.find(p => p.mobile === mobileNumber && p.id !== editPlayerId);
                if (playerWithSameMobile) {
                    alert('A player with this mobile number already exists. Please use a unique mobile number or edit the existing player.');
                    return;
                }

                if (editPlayerId) {
                    onUpdatePlayer({
                        id: editPlayerId,
                        name: playerName,
                        mobile: mobileNumber,
                        categories: selectedPlayerCategories,
                        feePaid: feePaid,
                    });
                    alert('Player updated successfully!');
                } else {
                    onAddPlayer({
                        id: generateUUID(),
                        name: playerName,
                        mobile: mobileNumber,
                        categories: selectedPlayerCategories,
                        feePaid: feePaid,
                    });
                    alert('Player added successfully!');
                }
                resetForm();
            };

            const handleEdit = (player) => {
                setPlayerName(player.name);
                setMobileNumber(player.mobile);
                setSelectedPlayerCategories(player.categories);
                setFeePaid(player.feePaid);
                setEditPlayerId(player.id);
                window.scrollTo({ top: 0, behavior: 'smooth' }); // Scroll to top to make form visible
            };

            const handleCsvUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const csvString = event.target.result;
                        const parsedData = parseCsv(csvString);
                        
                        let playersToAdd = [];
                        let existingMobiles = new Set(players.map(p => p.mobile));
                        
                        // Define a mapping for CSV category numbers to enum values
                        const csvCategoryMap = {
                            'Open': PlayerCategory.OPEN,
                            '30': PlayerCategory.THIRTY_PLUS,
                            '40': PlayerCategory.FORTY_PLUS,
                            '50': PlayerCategory.FIFTY_PLUS,
                            '60': PlayerCategory.SIXTY_PLUS,
                            '70': PlayerCategory.SEVENTY_PLUS,
                            '30+': PlayerCategory.THIRTY_PLUS, // Also handle if CSV already has '+'
                            '40+': PlayerCategory.FORTY_PLUS,
                            '50+': PlayerCategory.FIFTY_PLUS,
                            '60+': PlayerCategory.SIXTY_PLUS,
                            '70+': PlayerCategory.SEVENTY_PLUS,
                        };

                        parsedData.forEach(row => {
                            // Corrected to use 'MobileNumber' and 'Categories' based on the image and warnings
                            const name = row['Name'];
                            const mobile = row['MobileNumber']; 
                            const rawCategoryFromCsv = row['Categories']; 
                            const feePaidStatus = row['Paid(Y/N)']?.toUpperCase() === 'Y';

                            const categories = [];
                            if (rawCategoryFromCsv) {
                                // Map the raw CSV category to the actual PlayerCategory enum value
                                const mappedCategory = csvCategoryMap[rawCategoryFromCsv];

                                // Check if the mapped category is valid and included in tournament settings
                                if (mappedCategory && tournamentSettings.categories.includes(mappedCategory)) {
                                    categories.push(mappedCategory);
                                } else {
                                    console.warn(`Skipping category "${rawCategoryFromCsv}" from CSV: Invalid or not defined in tournament settings.`);
                                }
                            }

                            if (name && mobile && categories.length > 0) {
                                if (!existingMobiles.has(mobile)) {
                                    playersToAdd.push({
                                        id: generateUUID(),
                                        name: name,
                                        mobile: mobile,
                                        categories: categories, // Will contain 0 or 1 category from CSV
                                        feePaid: feePaidStatus,
                                    });
                                    existingMobiles.add(mobile); // Mark as added to avoid duplicates in current batch
                                } else {
                                    console.warn(`Skipping player ${name} (Mobile: ${mobile}) from CSV: Mobile number already exists.`);
                                }
                            } else {
                                console.warn(`Skipping CSV row due to missing required data or invalid categories: ${JSON.stringify(row)}`);
                            }
                        });

                        if (playersToAdd.length > 0) {
                            onAddPlayersFromCsv(playersToAdd);
                            alert(`${playersToAdd.length} players added from CSV successfully!`);
                        } else {
                            alert('No new valid players found in CSV to add or all players already exist.');
                        }
                        csvFileInputRef.current.value = ''; // Clear file input
                    };
                    reader.readAsText(file);
                }
            };
            
            const groupedPlayers = players.reduce((acc, player) => {
                if (!acc[player.mobile]) {
                    acc[player.mobile] = [];
                }
                acc[player.mobile].push(player);
                return acc;
            }, {});

            // Calculate player counts per category for the warning message
            const categoryPlayerCounts = tournamentSettings.categories.reduce((acc, category) => {
                acc[category] = players.filter(p => p.categories.includes(category)).length;
                return acc;
            }, {});

            const categoriesOverLimit = Object.entries(categoryPlayerCounts).filter(([, count]) => count > PLAYER_LIMIT_PER_CATEGORY);


            return (
                <div className="bg-slate-800 p-6 rounded-lg shadow-lg mb-6">
                    <h3 className="text-xl font-semibold text-slate-100 mb-4">Manage Players</h3>

                    <form onSubmit={handleSubmit} className="space-y-4 mb-6">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label htmlFor="playerName" className="block text-slate-300 text-sm font-bold mb-2">
                                    Player Name <span className="text-red-400">*</span>
                                </label>
                                <input
                                    type="text"
                                    id="playerName"
                                    className="shadow appearance-none border rounded w-full py-2 px-3 text-slate-200 leading-tight focus:outline-none focus:shadow-outline bg-slate-700 border-slate-600 focus:border-sky-500 focus:ring-sky-500"
                                    value={playerName}
                                    onChange={(e) => setPlayerName(e.target.value)}
                                    required
                                    aria-required="true"
                                    aria-label="Player Name"
                                />
                            </div>
                            <div>
                                <label htmlFor="mobileNumber" className="block text-slate-300 text-sm font-bold mb-2">
                                    Mobile Number <span className="text-red-400">*</span>
                                </label>
                                <input
                                    type="text"
                                    id="mobileNumber"
                                    className="shadow appearance-none border rounded w-full py-2 px-3 text-slate-200 leading-tight focus:outline-none focus:shadow-outline bg-slate-700 border-slate-600 focus:border-sky-500 focus:ring-sky-500"
                                    value={mobileNumber}
                                    onChange={(e) => setMobileNumber(e.target.value)}
                                    required
                                    aria-required="true"
                                    aria-label="Mobile Number"
                                />
                            </div>
                        </div>

                        <div>
                            <label className="block text-slate-300 text-sm font-bold mb-2">
                                Categories (max 2) <span className="text-red-400">*</span>
                            </label>
                            <div className="grid grid-cols-2 sm:grid-cols-4 gap-2" role="group" aria-labelledby="player-categories-label">
                                {tournamentSettings.categories.length === 0 ? (
                                    <p className="text-slate-400 text-sm italic">Define tournament categories first in settings.</p>
                                ) : (
                                    tournamentSettings.categories.map(category => (
                                        <label key={category} className="flex items-center text-slate-200">
                                            <input
                                                type="checkbox"
                                                checked={selectedPlayerCategories.includes(category)}
                                                onChange={() => handlePlayerCategoryChange(category)}
                                                disabled={!selectedPlayerCategories.includes(category) && selectedPlayerCategories.length >= 2}
                                                className="form-checkbox h-4 w-4 text-sky-600 bg-slate-700 border-slate-600 rounded focus:ring-sky-500 disabled:opacity-50"
                                                aria-label={`Category ${category}`}
                                            />
                                            <span className="ml-2 text-sm">{category}</span>
                                        </label>
                                    ))
                                )}
                            </div>
                            {selectedPlayerCategories.length === 0 && (
                                <p className="text-red-400 text-xs mt-1" role="alert">Please select at least one category.</p>
                            )}
                        </div>

                        <div className="flex items-center">
                            <input
                                type="checkbox"
                                id="feePaid"
                                checked={feePaid}
                                onChange={(e) => setFeePaid(e.target.checked)}
                                className="form-checkbox h-4 w-4 text-sky-600 bg-slate-700 border-slate-600 rounded focus:ring-sky-500"
                                aria-label="Fee Paid"
                            />
                            <label htmlFor="feePaid" className="ml-2 text-slate-200 text-sm">Fee Paid</label>
                        </div>

                        <div className="flex space-x-2">
                            <button
                                type="submit"
                                className="flex-1 bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors"
                                aria-label={editPlayerId ? 'Update Player' : 'Add Player'}
                            >
                                {editPlayerId ? 'Update Player' : 'Add Player'}
                            </button>
                            {editPlayerId && (
                                <button
                                    type="button"
                                    onClick={resetForm}
                                    className="flex-1 bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors"
                                    aria-label="Cancel Edit"
                                >
                                    Cancel Edit
                                </button>
                            )}
                        </div>
                    </form>

                    <div className="mb-6">
                        <label htmlFor="csvUpload" className="block text-slate-300 text-sm font-bold mb-2">
                            Upload Players via CSV
                        </label>
                        <input
                            type="file"
                            id="csvUpload"
                            accept=".csv"
                            onChange={handleCsvUpload}
                            ref={csvFileInputRef}
                            className="block w-full text-sm text-slate-400
                                file:mr-4 file:py-2 file:px-4
                                file:rounded-lg file:border-0
                                file:text-sm file:font-semibold
                                file:bg-sky-500 file:text-white
                                hover:file:bg-sky-600
                                bg-slate-700 rounded-lg cursor-pointer transition-colors"
                            aria-label="Upload Players CSV"
                        />
                        <p className="text-xs text-slate-500 mt-2">Expected CSV headers: "Name", "MobileNumber", "Categories", "Paid(Y/N)". Category values like "40" or "40+" will map to "40+". Only adds new players. Players can be manually edited to add a second category if applicable.</p>
                    </div>

                    {categoriesOverLimit.length > 0 && (
                        <div className="bg-orange-900/30 border border-orange-700 text-orange-300 p-4 rounded-md mb-6 flex items-start gap-3" role="alert">
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 flex-shrink-0 mt-0.5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                                <path strokeLinecap="round" strokeLinejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                            </svg>
                            <div>
                                <h4 className="font-bold">Player Count Warning ({PLAYER_LIMIT_PER_CATEGORY}+ players)</h4>
                                <p>The following categories have a high number of players, which might indicate a large tournament scope or potential data management challenges for a single category:</p>
                                <ul className="list-disc list-inside mt-1">
                                    {categoriesOverLimit.map(([category, count]) => (
                                        <li key={category}>{category}: {count} players</li>
                                    ))}
                                </ul>
                                <p className="text-sm mt-2">Consider reviewing the player list or the tournament structure if this is unexpected.</p>
                            </div>
                        </div>
                    )}

                    <h4 className="text-lg font-semibold text-slate-200 mb-3">Registered Players</h4>
                    {Object.keys(groupedPlayers).length === 0 ? (
                        <p className="text-slate-400">No players registered yet.</p>
                    ) : (
                        <div className="overflow-x-auto rounded-lg shadow">
                            <table className="min-w-full divide-y divide-slate-700" aria-label="Registered Players Table">
                                <thead className="bg-slate-900">
                                    <tr>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                            Mobile Number
                                        </th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                            Player Name(s)
                                        </th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                            Categories
                                        </th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                            Fee Paid
                                        </th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                            Actions
                                        </th>
                                    </tr>
                                </thead>
                                <tbody className="bg-slate-800 divide-y divide-slate-700">
                                    {Object.entries(groupedPlayers).map(([mobile, playersArr]) => (
                                        <tr key={mobile} className="hover:bg-slate-700">
                                            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-200">
                                                {mobile}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-slate-300">
                                                {playersArr.map(p => p.name).join(', ')}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-slate-300">
                                                {playersArr.map(p => p.categories.join(' & ')).join('; ')}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-slate-300">
                                                {playersArr.every(p => p.feePaid) ? 'Yes' : 'No'}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                                {playersArr.map(player => (
                                                    <div key={player.id} className="flex gap-2 mb-1 last:mb-0 justify-end">
                                                        <button
                                                            onClick={() => handleEdit(player)}
                                                            className="text-indigo-400 hover:text-indigo-300 text-xs"
                                                            aria-label={`Edit ${player.name}`}
                                                        >
                                                            Edit
                                                        </button>
                                                        <button
                                                            onClick={() => onDeletePlayer(player.id)}
                                                            className="text-red-400 hover:text-red-300 text-xs ml-2"
                                                            aria-label={`Delete ${player.name}`}
                                                        >
                                                            Delete
                                                        </button>
                                                    </div>
                                                ))}
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    )}
                </div>
            );
        };

        const FixtureManagement = ({ players, tournamentSettings, fixtures, onGenerateFixtures, onUpdateScore, onUploadCustomFixtures }) => {
            const [selectedCategory, setSelectedCategory] = useState(tournamentSettings.categories[0] || null);
            const [selectedType, setSelectedType] = useState(tournamentSettings.types[0] || null);
            const customFixtureFileInputRef = useRef(null);

            const [showHistoryModal, setShowHistoryModal] = useState(false);
            const [currentMatchHistory, setCurrentMatchHistory] = useState([]);
            const [currentMatchDetails, setCurrentMatchDetails] = useState(null); // To show player names in modal header

            useEffect(() => {
                if (tournamentSettings.categories.length > 0 && (!selectedCategory || !tournamentSettings.categories.includes(selectedCategory))) {
                    setSelectedCategory(tournamentSettings.categories[0]);
                } else if (tournamentSettings.categories.length === 0) {
                    setSelectedCategory(null);
                }
                if (tournamentSettings.types.length > 0 && (!selectedType || !tournamentSettings.types.includes(selectedType))) {
                    setSelectedType(tournamentSettings.types[0]);
                } else if (tournamentSettings.types.length === 0) {
                    setSelectedType(null);
                }
            }, [tournamentSettings, selectedCategory, selectedType]);

            const getPlayerName = useCallback((playerId) => {
                const player = players.find(p => p.id === playerId);
                return player ? player.name : `Unknown Player (${playerId.substring(0,4)})`;
            }, [players]);

            const handleCustomFixtureUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const jsonString = event.target.result;
                            const customFixtures = JSON.parse(jsonString);
                            // Basic validation for custom fixtures structure
                            if (Array.isArray(customFixtures) && customFixtures.every(f => f.category && f.tournamentType && Array.isArray(f.groups) && Array.isArray(f.matches))) {
                                onUploadCustomFixtures(customFixtures);
                                alert('Custom fixtures uploaded successfully!');
                            } else {
                                alert('Invalid custom fixture JSON format. Please ensure it matches the expected structure: Array of { category, tournamentType, groups: [], matches: [] }');
                            }
                        } catch (error) {
                            alert('Error parsing custom fixture JSON: ' + error.message);
                        } finally {
                            if (customFixtureFileInputRef.current) {
                                customFixtureFileInputRef.current.value = '';
                            }
                        }
                    };
                    reader.readAsText(file);
                }
            };

            const currentCategoryFixtures = fixtures.filter(f =>
                f.category === selectedCategory && f.tournamentType === selectedType
            );

            const handleViewHistory = (match, player1Name, player2Name) => {
                setCurrentMatchHistory(match.history);
                setCurrentMatchDetails({ player1Name, player2Name });
                setShowHistoryModal(true);
            };

            return (
                <div className="bg-slate-800 p-6 rounded-lg shadow-lg mb-6">
                    <h3 className="text-xl font-semibold text-slate-100 mb-4">Fixture & Score Management</h3>

                    <div className="flex flex-col sm:flex-row gap-4 mb-4">
                        <div className="flex-1">
                            <label htmlFor="selectCategory" className="block text-slate-300 text-sm font-bold mb-2">Select Category</label>
                            <select
                                id="selectCategory"
                                value={selectedCategory || ''}
                                onChange={(e) => setSelectedCategory(e.target.value)}
                                className="block w-full py-2 px-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 text-white sm:text-sm"
                                aria-label="Select Category for Fixtures"
                                disabled={tournamentSettings.categories.length === 0}
                            >
                                {tournamentSettings.categories.length === 0 ? (
                                    <option value="">No categories defined</option>
                                ) : (
                                    tournamentSettings.categories.map(cat => (
                                        <option key={cat} value={cat}>{cat}</option>
                                    ))
                                )}
                            </select>
                        </div>
                        <div className="flex-1">
                            <label htmlFor="selectType" className="block text-slate-300 text-sm font-bold mb-2">Select Type</label>
                            <select
                                id="selectType"
                                value={selectedType || ''}
                                onChange={(e) => setSelectedType(e.target.value)}
                                className="block w-full py-2 px-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 text-white sm:text-sm"
                                aria-label="Select Tournament Type for Fixtures"
                                disabled={tournamentSettings.types.length === 0}
                            >
                                {tournamentSettings.types.length === 0 ? (
                                    <option value="">No types defined</option>
                                ) : (
                                    tournamentSettings.types.map(type => (
                                        <option key={type} value={type}>{type}</option>
                                    ))
                                )}
                            </select>
                        </div>
                    </div>


                    <div className="flex flex-col md:flex-row gap-4 mb-6">
                        <button
                            onClick={() => onGenerateFixtures(selectedCategory, selectedType)}
                            className="flex-1 bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                            disabled={!selectedCategory || !selectedType || players.length === 0}
                            aria-label="Generate Fixtures"
                        >
                            Generate Fixtures
                        </button>
                        <div className="flex-1">
                            <label htmlFor="customFixtureUpload" className="sr-only">Upload Custom Fixtures</label>
                            <input
                                type="file"
                                id="customFixtureUpload"
                                accept=".json"
                                onChange={handleCustomFixtureUpload}
                                ref={customFixtureFileInputRef}
                                className="block w-full text-sm text-slate-400
                                    file:mr-4 file:py-2 file:px-4
                                    file:rounded-lg file:border-0
                                    file:text-sm file:font-semibold
                                    file:bg-slate-600 file:text-white
                                    hover:file:bg-slate-700
                                    bg-slate-700 rounded-lg cursor-pointer transition-colors"
                                aria-label="Upload Custom Fixtures JSON"
                            />
                            <p className="text-xs text-slate-500 mt-1">Upload JSON for custom fixtures for selected category/type</p>
                        </div>
                    </div>

                    {(tournamentSettings.categories.length === 0 || tournamentSettings.types.length === 0) ? (
                        <p className="text-red-400 italic">Please define tournament types and categories in settings before managing fixtures.</p>
                    ) : players.length === 0 ? (
                        <p className="text-red-400 italic">Please add players before generating fixtures.</p>
                    ) : currentCategoryFixtures.length === 0 ? (
                        <p className="text-slate-400">No fixtures generated or uploaded for this category/type yet. Click 'Generate Fixtures' or 'Upload Custom Fixtures'.</p>
                    ) : (
                        currentCategoryFixtures.map(catFix => (
                            <div key={`${catFix.category}-${catFix.tournamentType}`} className="space-y-6">
                                <h4 className="text-lg font-semibold text-slate-200 mb-2">{catFix.category} - {catFix.tournamentType} Fixtures</h4>
                                {catFix.groups.map(group => (
                                    <div key={group.id} className="bg-slate-700 p-4 rounded-lg">
                                        <h5 className="font-bold text-slate-100 mb-3">{group.name}</h5>
                                        <p className="text-sm text-slate-300 mb-4">Players: {group.playerIds.map(getPlayerName).join(', ')}</p>
                                        <div className="overflow-x-auto">
                                            <table className="min-w-full divide-y divide-slate-600" aria-label={`Matches for ${group.name}`}>
                                                <thead className="bg-slate-800">
                                                    <tr>
                                                        <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                            Match
                                                        </th>
                                                        <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                            Player 1
                                                        </th>
                                                        <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                            Player 2
                                                        </th>
                                                        <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                            Score (P1 - P2)
                                                        </th>
                                                        <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                            Status
                                                        </th>
                                                        <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                            Actions
                                                        </th>
                                                    </tr>
                                                </thead>
                                                <tbody className="bg-slate-700 divide-y divide-slate-600">
                                                    {catFix.matches
                                                        .filter(match =>
                                                            group.playerIds.includes(match.player1Id) && group.playerIds.includes(match.player2Id)
                                                        )
                                                        .map(match => {
                                                            const disableScoreInputs = match.status === 'completed';
                                                            return (
                                                                <tr key={match.id} className="hover:bg-slate-600">
                                                                    <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-200">
                                                                        {getPlayerName(match.player1Id)} vs {getPlayerName(match.player2Id)}
                                                                    </td>
                                                                    <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-300">
                                                                        {getPlayerName(match.player1Id)}
                                                                    </td>
                                                                    <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-300">
                                                                        {getPlayerName(match.player2Id)}
                                                                    </td>
                                                                    <td className="px-4 py-3 whitespace-nowrap text-sm">
                                                                        <div className="flex items-center space-x-2">
                                                                            <input
                                                                                type="number"
                                                                                min="0"
                                                                                className="w-16 bg-slate-600 text-slate-200 text-center rounded-md text-sm py-1 px-1 focus:ring-sky-500 focus:border-sky-500 disabled:opacity-50 disabled:cursor-not-allowed"
                                                                                value={match.score1 === null ? '' : match.score1}
                                                                                onChange={(e) => onUpdateScore(match.id, parseInt(e.target.value), match.score2, 'score1')}
                                                                                aria-label={`Score for ${getPlayerName(match.player1Id)}`}
                                                                                disabled={disableScoreInputs}
                                                                            />
                                                                            <span>-</span>
                                                                            <input
                                                                                type="number"
                                                                                min="0"
                                                                                className="w-16 bg-slate-600 text-slate-200 text-center rounded-md text-sm py-1 px-1 focus:ring-sky-500 focus:border-sky-500 disabled:opacity-50 disabled:cursor-not-allowed"
                                                                                value={match.score2 === null ? '' : match.score2}
                                                                                onChange={(e) => onUpdateScore(match.id, match.score1, parseInt(e.target.value), 'score2')}
                                                                                aria-label={`Score for ${getPlayerName(match.player2Id)}`}
                                                                                disabled={disableScoreInputs}
                                                                            />
                                                                        </div>
                                                                    </td>
                                                                    <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-300 capitalize">
                                                                        {match.status.replace(/_/g, ' ')}
                                                                    </td>
                                                                    <td className="px-4 py-3 whitespace-nowrap text-right text-sm font-medium flex items-center justify-end">
                                                                        <select
                                                                            value={match.status}
                                                                            onChange={(e) => onUpdateScore(match.id, match.score1, match.score2, 'status', e.target.value)}
                                                                            className="bg-slate-600 text-slate-200 rounded-md text-sm py-1 px-2 focus:ring-sky-500 focus:border-sky-500"
                                                                            aria-label={`Update status for match ${getPlayerName(match.player1Id)} vs ${getPlayerName(match.player2Id)}`}
                                                                        >
                                                                            <option value="scheduled">Scheduled</option>
                                                                            <option value="in-progress">In-Progress</option>
                                                                            <option value="completed">Completed</option>
                                                                            <option value="walkover_p1">Walkover (P1)</option>
                                                                            <option value="walkover_p2">Walkover (P2)</option>
                                                                            <option value="disqualified">Disqualified</option>
                                                                        </select>
                                                                        <button
                                                                            onClick={() => handleViewHistory(match, getPlayerName(match.player1Id), getPlayerName(match.player2Id))}
                                                                            className="text-sky-400 hover:text-sky-300 text-xs ml-2 py-1 px-2 bg-slate-700 rounded-md"
                                                                            aria-label={`View history for match ${getPlayerName(match.player1Id)} vs ${getPlayerName(match.player2Id)}`}
                                                                        >
                                                                            History
                                                                        </button>
                                                                    </td>
                                                                </tr>
                                                            );
                                                        })}
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        ))
                    )}

                    {showHistoryModal && (
                        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
                            <div className="bg-slate-800 p-6 rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto">
                                <div className="flex justify-between items-center mb-4">
                                    <h4 className="text-xl font-semibold text-slate-100">
                                        Match History: {currentMatchDetails?.player1Name} vs {currentMatchDetails?.player2Name}
                                    </h4>
                                    <button
                                        onClick={() => setShowHistoryModal(false)}
                                        className="text-slate-400 hover:text-slate-200"
                                        aria-label="Close history modal"
                                    >
                                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                                            <path strokeLinecap="round" strokeLinejoin="round" d="M6 18L18 6M6 6l12 12" />
                                        </svg>
                                    </button>
                                </div>
                                {currentMatchHistory.length === 0 ? (
                                    <p className="text-slate-400">No history available for this match.</p>
                                ) : (
                                    <div className="overflow-x-auto rounded-lg shadow">
                                        <table className="min-w-full divide-y divide-slate-700">
                                            <thead className="bg-slate-900">
                                                <tr>
                                                    <th className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase">Timestamp</th>
                                                    <th className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase">Changed By</th>
                                                    <th className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase">Old State</th>
                                                    <th className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase">New State</th>
                                                    <th className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase">Reason</th>
                                                </tr>
                                            </thead>
                                            <tbody className="bg-slate-700 divide-y divide-slate-600">
                                                {currentMatchHistory.map((log, index) => (
                                                    <tr key={index} className="hover:bg-slate-600">
                                                        <td className="px-4 py-2 whitespace-nowrap text-sm text-slate-200">{new Date(log.timestamp).toLocaleString()}</td>
                                                        <td className="px-4 py-2 whitespace-nowrap text-sm text-slate-300">{log.changedBy}</td>
                                                        <td className="px-4 py-2 whitespace-nowrap text-sm text-slate-300">
                                                            P1: {log.oldScore1 ?? 'N/A'}, P2: {log.oldScore2 ?? 'N/A'} <br /> Status: {log.oldStatus.replace(/_/g, ' ')}
                                                        </td>
                                                        <td className="px-4 py-2 whitespace-nowrap text-sm text-slate-300">
                                                            P1: {log.newScore1 ?? 'N/A'}, P2: {log.newScore2 ?? 'N/A'} <br /> Status: {log.newStatus.replace(/_/g, ' ')}
                                                        </td>
                                                        <td className="px-4 py-2 text-sm text-slate-300">{log.reason}</td>
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const AdminDashboard = ({ tournamentData, setTournamentData, onPublish, isPublishing, setIsPublishing }) => {
            // isPublishing state is now managed by the parent App component

            const saveTournamentSettings = (newSettings) => {
                setTournamentData(prev => ({ ...prev, settings: newSettings }));
            };

            const addPlayer = (newPlayer) => {
                setTournamentData(prev => ({ ...prev, players: [...prev.players, newPlayer] }));
            };

            const addPlayersFromCsv = (newPlayers) => {
                setTournamentData(prev => {
                    // This handles duplicates by mobile number that might occur if CSV contains duplicates or existing players
                    const uniqueNewPlayers = [];
                    const existingMobiles = new Set(prev.players.map(p => p.mobile));
                    
                    newPlayers.forEach(np => {
                        if (!existingMobiles.has(np.mobile)) {
                            uniqueNewPlayers.push(np);
                            existingMobiles.add(np.mobile); // Add to temp set for current batch
                        }
                    });
                    return { ...prev, players: [...prev.players, ...uniqueNewPlayers] };
                });
            };

            const updatePlayer = (updatedPlayer) => {
                setTournamentData(prev => ({
                    ...prev,
                    players: prev.players.map(p => p.id === updatedPlayer.id ? updatedPlayer : p)
                }));
            };

            const deletePlayer = (playerId) => {
                if (window.confirm('Are you sure you want to delete this player? This will also remove them from any generated fixtures.')) {
                    setTournamentData(prev => ({
                        ...prev,
                        players: prev.players.filter(p => p.id !== playerId),
                        // Also remove player from any existing fixtures
                        fixtures: prev.fixtures.map(catFix => ({
                            ...catFix,
                            groups: catFix.groups.map(group => ({
                                ...group,
                                playerIds: group.playerIds.filter(id => id !== playerId)
                            })).filter(group => group.playerIds.length >= 2), // Remove groups that become too small
                            matches: catFix.matches.filter(match => match.player1Id !== playerId && match.player2Id !== playerId)
                        })).filter(catFix => catFix.groups.length > 0) // Remove categories without any valid groups
                    }));
                    alert('Player deleted successfully!');
                }
            };

            const generateFixtures = (category, type) => {
                if (!category || !type) {
                    alert('Please select a category and tournament type to generate fixtures.');
                    return;
                }

                const playersForCategoryAndType = tournamentData.players.filter(p =>
                    p.categories.includes(category)
                );

                // Minimum 4 players to form a group of 4-6
                const MIN_GROUP_SIZE = 4; 
                const MAX_GROUP_SIZE = 6;

                if (playersForCategoryAndType.length < MIN_GROUP_SIZE) { 
                    alert(`Not enough players for category "${category}" and type "${type}". Need at least ${MIN_GROUP_SIZE} players. Found: ${playersForCategoryAndType.length}`);
                    return;
                }
                
                const playerIdsForGrouping = playersForCategoryAndType.map(p => p.id);

                const grouped = groupPlayersRandomly({[category]: {[type]: playerIdsForGrouping}}, MIN_GROUP_SIZE, MAX_GROUP_SIZE);
                const groupsForCurrentCategoryType = grouped[category][type];

                if (!groupsForCurrentCategoryType || groupsForCurrentCategoryType.length === 0) {
                     alert(`Could not form valid groups for category "${category}" and type "${type}" with ${playersForCategoryAndType.length} players (min: ${MIN_GROUP_SIZE}, max: ${MAX_GROUP_SIZE}). Consider adjusting player count.`);
                     return;
                }

                const matchesForCategoryType = [];
                groupsForCurrentCategoryType.forEach(group => {
                    const groupMatches = generateRoundRobinMatches(group.playerIds, category, type, group.name);
                    matchesForCategoryType.push(...groupMatches);
                });

                const newCategoryFixture = {
                    category: category,
                    tournamentType: type,
                    groups: groupsForCurrentCategoryType,
                    matches: matchesForCategoryType,
                };

                // Merge with existing fixtures, update or add.
                setTournamentData(prev => {
                    const existingFixtures = prev.fixtures.filter(f => !(f.category === category && f.tournamentType === type));
                    return { ...prev, fixtures: [...existingFixtures, newCategoryFixture] };
                });
                alert('Fixtures generated successfully! Now, click "Publish Tournament to Players" at the bottom to make them visible!');
            };

            const uploadCustomFixtures = (customFixtures) => {
                 setTournamentData(prev => {
                    // Filter out existing fixtures for the same category/type as in customFixtures
                    const filteredExistingFixtures = prev.fixtures.filter(existingF =>
                        !customFixtures.some(customF =>
                            customF.category === existingF.category && customF.tournamentType === existingF.tournamentType
                        )
                    );
                    
                    // Ensure history array exists for each match in uploaded custom fixtures
                    const processedCustomFixtures = customFixtures.map(catFix => ({
                        ...catFix,
                        matches: catFix.matches.map(match => ({
                            history: match.history || [], // Ensure history exists
                            ...match
                        }))
                    }));

                    return { ...prev, fixtures: [...filteredExistingFixtures, ...processedCustomFixtures] };
                });
            };


            const updateScore = (matchId, score1Value, score2Value, fieldToUpdate, statusValue = null) => {
                setTournamentData(prev => ({
                    ...prev,
                    fixtures: prev.fixtures.map(catFix => ({
                        ...catFix,
                        matches: catFix.matches.map(match => {
                            if (match.id === matchId) {
                                const oldScore1 = match.score1;
                                const oldScore2 = match.score2;
                                const oldStatus = match.status;

                                let newScore1 = match.score1;
                                let newScore2 = match.score2;
                                let newStatus = match.status;

                                if (fieldToUpdate === 'score1') {
                                    newScore1 = (score1Value === '' || isNaN(score1Value)) ? null : Math.max(0, parseInt(score1Value));
                                } else if (fieldToUpdate === 'score2') {
                                    newScore2 = (score2Value === '' || isNaN(score2Value)) ? null : Math.max(0, parseInt(score2Value));
                                } else if (fieldToUpdate === 'status') {
                                    newStatus = statusValue;
                                }

                                // Apply special status logic immediately when status changes
                                if (fieldToUpdate === 'status') {
                                    if (newStatus === 'walkover_p1') {
                                        newScore1 = 1;
                                        newScore2 = 0;
                                        newStatus = 'completed'; // Mark as completed
                                    } else if (newStatus === 'walkover_p2') {
                                        newScore1 = 0;
                                        newScore2 = 1;
                                        newStatus = 'completed'; // Mark as completed
                                    } else if (newStatus === 'disqualified') {
                                        newScore1 = 0;
                                        newScore2 = 0;
                                        newStatus = 'completed'; // Mark as completed
                                    } else if (newStatus === 'scheduled' || newStatus === 'in-progress') {
                                        // If status is changed back to non-completed, clear scores
                                        newScore1 = null;
                                        newScore2 = null;
                                    }
                                }

                                // Validation for "Completed" status (including auto-completed ones)
                                if (newStatus === 'completed' && (newScore1 === null || newScore2 === null || isNaN(newScore1) || isNaN(newScore2))) {
                                    alert('Scores are required for both players when marking a match as "Completed".');
                                    return match; // Revert to original match if validation fails
                                }
                                
                                // Check if any significant change occurred to log it
                                const scoresChanged = oldScore1 !== newScore1 || oldScore2 !== newScore2;
                                const statusChanged = oldStatus !== newStatus;

                                if (scoresChanged || statusChanged) {
                                    const logEntry = {
                                        timestamp: new Date().toISOString(),
                                        changedBy: 'Admin', // Assuming only admin can make changes via this UI
                                        oldScore1: oldScore1,
                                        oldScore2: oldScore2,
                                        oldStatus: oldStatus,
                                        newScore1: newScore1,
                                        newScore2: newScore2,
                                        newStatus: newStatus,
                                        reason: fieldToUpdate === 'status' ? `Status changed to ${newStatus.replace(/_/g, ' ').toUpperCase()}` : 'Scores updated',
                                    };
                                    return {
                                        ...match,
                                        score1: newScore1,
                                        score2: newScore2,
                                        status: newStatus,
                                        history: [...match.history, logEntry],
                                    };
                                }
                                // If no changes, return the original match object
                                return match;
                            }
                            return match;
                        })
                    }))
                }));
            };

            const handlePublishClick = async () => {
                // Removed window.confirm as per previous user request. Publish directly.
                console.log('AdminDashboard: handlePublishClick - Initiating publish process.');
                setIsPublishing(true); // Start loading state
                try {
                    await new Promise(resolve => setTimeout(resolve, 500)); // Simulate API call or heavy operation
                    onPublish(); // This updates tournamentData.isPublished in App
                    alert('Tournament successfully published to players!'); // Success message after publish
                } catch (error) {
                    console.error("Failed to publish tournament:", error);
                    alert("Failed to publish tournament. Please try again.");
                } finally {
                    setIsPublishing(false); // End loading state
                }
            };

            // Helper to get player name by ID for CSV exports
            const getPlayerNameForExport = useCallback((playerId) => {
                const player = tournamentData.players.find(p => p.id === playerId);
                return player ? player.name : `Unknown Player (ID: ${playerId ? playerId.substring(0, 4) : 'N/A'})`;
            }, [tournamentData.players]);

            // CSV Export utility
            const exportToCsv = (filename, rows) => {
                const escapedRows = rows.map(row => 
                    row.map(field => {
                        // Ensure all fields are strings and escape commas/quotes
                        const stringField = String(field === null || field === undefined ? '' : field);
                        if (stringField.includes(',') || stringField.includes('"') || stringField.includes('\n')) {
                            return `"${stringField.replace(/"/g, '""')}"`;
                        }
                        return stringField;
                    }).join(',')
                );
                const csvString = escapedRows.join('\n');
                const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.click();
                URL.revokeObjectURL(url);
            };

            const exportPlayersData = () => {
                if (tournamentData.players.length === 0) {
                    alert('No players to export.');
                    return;
                }
                const headers = ["Player ID", "Name", "Mobile Number", "Category 1", "Category 2", "Fee Paid"];
                const rows = [headers];

                tournamentData.players.forEach(player => {
                    rows.push([
                        player.id,
                        player.name,
                        player.mobile,
                        player.categories[0] || '',
                        player.categories[1] || '',
                        player.feePaid ? 'Yes' : 'No'
                    ]);
                });
                exportToCsv('players_data.csv', rows);
            };

            const exportFixturesData = () => {
                if (tournamentData.fixtures.length === 0) {
                    alert('No fixtures to export.');
                    return;
                }
                const headers = ["Category", "Tournament Type", "Group ID", "Group Name", "Players in Group (Names)", "Players in Group (IDs)"];
                const rows = [headers];

                tournamentData.fixtures.forEach(catFix => {
                    catFix.groups.forEach(group => {
                        rows.push([
                            catFix.category,
                            catFix.tournamentType,
                            group.id,
                            group.name,
                            group.playerIds.map(getPlayerNameForExport).join('; '), // Semicolon as separator for readability
                            group.playerIds.join('; ')
                        ]);
                    });
                });
                exportToCsv('fixtures_groups_data.csv', rows);
            };

            const exportMatchResultsData = () => {
                let allMatches = [];
                tournamentData.fixtures.forEach(catFix => {
                    allMatches.push(...catFix.matches);
                });

                if (allMatches.length === 0) {
                    alert('No match results to export.');
                    return;
                }

                const headers = ["Match ID", "Category", "Tournament Type", "Group Name", "Player 1 Name", "Player 2 Name", "Score Player 1", "Score Player 2", "Status"];
                const rows = [headers];

                allMatches.forEach(match => {
                    rows.push([
                        match.id,
                        match.category,
                        match.tournamentType,
                        match.groupName,
                        getPlayerNameForExport(match.player1Id),
                        getPlayerNameForExport(match.player2Id),
                        match.score1 === null ? '' : match.score1,
                        match.score2 === null ? '' : match.score2,
                        match.status.replace(/_/g, ' ') // Format status for readability
                    ]);
                });
                exportToCsv('match_results_data.csv', rows);
            };


            const canPublish = tournamentData.settings.name.trim() !== '' &&
                               tournamentData.settings.types.length > 0 &&
                               tournamentData.settings.categories.length > 0 &&
                               tournamentData.players.length > 0 &&
                               tournamentData.fixtures.length > 0;

            const publishDisabledReason = !tournamentData.settings.name.trim() ? 'Complete tournament name in settings.' :
                                          tournamentData.settings.types.length === 0 ? 'Select tournament types in settings.' :
                                          tournamentData.settings.categories.length === 0 ? 'Select player categories in settings.' :
                                          tournamentData.players.length === 0 ? 'Add players.' :
                                          tournamentData.fixtures.length === 0 ? 'Generate or upload fixtures.' :
                                          '';

            return (
                <div className="space-y-8">
                    <TournamentSetup settings={tournamentData.settings} onSaveSettings={saveTournamentSettings} />
                    <PlayerManagement
                        players={tournamentData.players}
                        tournamentSettings={tournamentData.settings}
                        onAddPlayer={addPlayer}
                        onUpdatePlayer={updatePlayer}
                        onDeletePlayer={deletePlayer}
                        onAddPlayersFromCsv={addPlayersFromCsv}
                    />
                    <FixtureManagement
                        players={tournamentData.players}
                        tournamentSettings={tournamentData.settings}
                        fixtures={tournamentData.fixtures}
                        onGenerateFixtures={generateFixtures}
                        onUpdateScore={updateScore}
                        onUploadCustomFixtures={uploadCustomFixtures}
                    />
                    <div className="bg-slate-800 p-6 rounded-lg shadow-lg mb-6">
                        <h3 className="text-xl font-semibold text-slate-100 mb-4">Export Data</h3>
                        <div className="flex flex-wrap gap-4">
                            <button
                                onClick={exportPlayersData}
                                className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled={tournamentData.players.length === 0}
                                aria-label="Export Player Information to CSV"
                            >
                                Export Players to CSV
                            </button>
                            <button
                                onClick={exportFixturesData}
                                className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled={tournamentData.fixtures.length === 0}
                                aria-label="Export Fixture Information to CSV"
                            >
                                Export Fixtures to CSV
                            </button>
                            <button
                                onClick={exportMatchResultsData}
                                className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled={tournamentData.fixtures.length === 0}
                                aria-label="Export Match Results to CSV"
                            >
                                Export Match Results to CSV
                            </button>
                        </div>
                    </div>

                    <button
                        onClick={handlePublishClick}
                        className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                        aria-label="Publish Tournament"
                        disabled={!canPublish || isPublishing}
                    >
                        {isPublishing ? 'Publishing...' : 'Publish Tournament to Players'}
                    </button>
                    {!canPublish && publishDisabledReason && (
                        <p className="text-red-400 text-sm text-center" role="status">
                            Cannot publish: {publishDisabledReason}
                        </p>
                    )}
                </div>
            );
        };

        const PlayerView = () => { // No longer receives tournamentData as a prop, fetches directly
            const [localTournamentData, setLocalTournamentData] = useState(null);
            const [selectedFilterCategory, setSelectedFilterCategory] = useState('All'); // State for players category filtering
            const [searchTerm, setSearchTerm] = useState(''); // New state for player search
            const [selectedFixtureFilterCategory, setSelectedFixtureFilterCategory] = useState('All'); // State for fixtures filtering
            const [selectedFixtureFilterGroup, setSelectedFixtureFilterGroup] = useState('All'); // NEW: State for group filtering

            // Define getPlayerName here, unconditionally, before any early returns
            const getPlayerName = useCallback((playerId) => {
                // Safely access players array even if localTournamentData is null or players is undefined
                const playersArray = localTournamentData?.players || [];
                const player = playersArray.find(p => p.id === playerId);
                return player ? player.name : `Unknown Player (${playerId ? playerId.substring(0,4) : 'N/A'})`;
            }, [localTournamentData]); // Depend on the entire localTournamentData object

            const fetchTournamentData = useCallback(() => {
                const storedData = getLocalStorage(LS_TOURNAMENT_DATA, null);
                console.log('PlayerView: Fetched from localStorage. isPublished:', storedData?.isPublished, 'Settings Name:', storedData?.settings?.name, 'Full Data:', storedData);
                setLocalTournamentData(storedData);
            }, []);

            useEffect(() => {
                fetchTournamentData();
            }, [fetchTournamentData]); // Fetch once on mount

            // Re-fetch if localStorage changes (e.g., admin publishes)
            useEffect(() => {
                const handleStorageChange = (event) => {
                    // Only react to changes in our specific key or if event.key is null (change in current tab/same origin)
                    if (event.key === LS_TOURNAMENT_DATA || event.key === null) {
                        console.log('PlayerView: localStorage "storage" event fired. Re-fetching data.');
                        fetchTournamentData();
                    }
                };
                window.addEventListener('storage', handleStorageChange);
                return () => window.removeEventListener('storage', handleStorageChange);
            }, [fetchTournamentData]);

            // NEW: Reset group filter when category filter changes
            useEffect(() => {
                setSelectedFixtureFilterGroup('All');
            }, [selectedFixtureFilterCategory]);


            if (!localTournamentData || !localTournamentData.settings || !localTournamentData.settings.name) {
                // No tournament data or basic settings are missing
                return (
                    <div className="min-h-[calc(100vh-80px)] flex flex-col items-center justify-center text-slate-400">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 mb-4 text-slate-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1}>
                          <path strokeLinecap="round" strokeLinejoin="round" d="M9.75 3.104l-2.286 9.144a3.75 3.75 0 003.75 4.498h1.5A3.75 3.75 0 0016.5 12.25l-2.286-9.144a3.75 3.75 0 00-4.464 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" d="M12 21a9.002 9.002 0 008.13-5.253M3.87 15.747A9.002 9.002 0 0012 21" />
                        </svg>
                        <h2 className="text-2xl font-bold mb-2">No Tournament Data Available</h2>
                        <p className="text-lg">An administrator needs to set up and publish a tournament.</p>
                    </div>
                );
            }

            if (!localTournamentData.isPublished) {
                // Tournament data exists, but it's not published
                 return (
                    <div className="min-h-[calc(100vh-80px)] flex flex-col items-center justify-center text-slate-400">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 mb-4 text-slate-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1}>
                          <path strokeLinecap="round" strokeLinejoin="round" d="M9.75 3.104l-2.286 9.144a3.75 3.75 0 003.75 4.498h1.5A3.75 3.75 0 0016.5 12.25l-2.286-9.144a3.75 3.75 0 00-4.464 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" d="M12 21a9.002 9.002 0 008.13-5.253M3.87 15.747A9.002 9.002 0 0012 21" />
                        </svg>
                        <h2 className="text-2xl font-bold mb-2">Tournament In Draft Mode</h2>
                        <p className="text-lg">This tournament has not yet been published by the administrator.</p>
                        <p className="text-lg">Check back later for tournament details and fixtures!</p>
                    </div>
                );
            }

            // Filter players based on selectedFilterCategory and searchTerm
            const lowerCaseSearchTerm = searchTerm.toLowerCase();
            const filteredPlayers = localTournamentData.players.filter(player => {
                const matchesCategory = selectedFilterCategory === 'All' || player.categories.includes(selectedFilterCategory);
                const matchesSearch = player.name.toLowerCase().includes(lowerCaseSearchTerm) || 
                                      player.mobile.includes(lowerCaseSearchTerm);
                return matchesCategory && matchesSearch;
            });


            const groupedPlayers = filteredPlayers.reduce((acc, player) => {
                if (!acc[player.mobile]) {
                    acc[player.mobile] = [];
                }
                acc[player.mobile].push(player);
                return acc;
            }, {});

            // Filter fixtures based on selectedFixtureFilterCategory
            const categoryFilteredFixtures = selectedFixtureFilterCategory === 'All'
                ? localTournamentData.fixtures
                : localTournamentData.fixtures.filter(catFix => catFix.category === selectedFixtureFilterCategory);


            return (
                <div className="container mx-auto p-4 sm:p-6 lg:p-8 space-y-8">
                    <h2 className="text-4xl font-bold text-sky-400 mb-6 text-center">
                        {localTournamentData.settings.name}
                    </h2>

                    <div className="bg-slate-800 p-6 rounded-lg shadow-lg">
                        <h3 className="text-2xl font-semibold text-slate-100 mb-4">Tournament Details</h3>
                        <p className="text-slate-300 mb-2">
                            <span className="font-medium text-slate-200">Types:</span> {localTournamentData.settings.types.join(', ')}
                        </p>
                        <p className="text-slate-300">
                            <span className="font-medium text-slate-200">Categories:</span> {localTournamentData.settings.categories.join(', ')}
                        </p>
                    </div>

                    <div className="bg-slate-800 p-6 rounded-lg shadow-lg">
                        <div className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-4">
                            <h3 className="2xl font-semibold text-slate-100">Registered Players</h3>
                            <div className="flex flex-col sm:flex-row items-stretch sm:items-center gap-2 w-full sm:w-auto">
                                <div className="flex-grow">
                                    <label htmlFor="playerSearch" className="sr-only">Search Players</label>
                                    <input
                                        type="text"
                                        id="playerSearch"
                                        placeholder="Search by name or mobile number..."
                                        value={searchTerm}
                                        onChange={(e) => setSearchTerm(e.target.value)}
                                        className="py-2 px-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 text-white sm:text-sm w-full"
                                        aria-label="Search players by name or mobile number"
                                    />
                                </div>
                                {localTournamentData.settings.categories.length > 0 && (
                                    <div className="flex items-center space-x-2 flex-shrink-0">
                                        <label htmlFor="categoryFilter" className="text-slate-300 text-sm sr-only">Filter by Category:</label>
                                        <select
                                            id="categoryFilter"
                                            value={selectedFilterCategory}
                                            onChange={(e) => setSelectedFilterCategory(e.target.value)}
                                            className="py-2 px-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 text-white sm:text-sm"
                                            aria-label="Filter players by category"
                                        >
                                            <option value="All">All Categories</option>
                                            {localTournamentData.settings.categories.map(category => (
                                                <option key={category} value={category}>{category}</option>
                                            ))}
                                        </select>
                                    </div>
                                )}
                            </div>
                        </div>
                        {Object.keys(groupedPlayers).length === 0 ? (
                            <p className="text-slate-400">No players registered yet or no players match the selected criteria.</p>
                        ) : (
                            <div className="overflow-x-auto rounded-lg shadow">
                                <table className="min-w-full divide-y divide-slate-700" aria-label="Registered Players Table">
                                    <thead className="bg-slate-900">
                                        <tr>
                                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                Mobile Number
                                            </th>
                                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                Player Name(s)
                                            </th>
                                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                Categories
                                            </th>
                                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                Fee Paid
                                            </th>
                                        </tr>
                                    </thead>
                                    <tbody className="bg-slate-800 divide-y divide-slate-700">
                                        {Object.entries(groupedPlayers).map(([mobile, playersArr]) => (
                                            <tr key={mobile} className="hover:bg-slate-700">
                                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-200">
                                                    {mobile}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-slate-300">
                                                    {playersArr.map(p => p.name).join(', ')}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-slate-300">
                                                    {playersArr.map(p => p.categories.join(' & ')).join('; ')}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-slate-300">
                                                    {playersArr.every(p => p.feePaid) ? 'Yes' : 'No'}
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </div>

                    <div className="bg-slate-800 p-6 rounded-lg shadow-lg">
                        <div className="flex flex-wrap gap-4 items-center mb-4">
                            <h3 className="2xl font-semibold text-slate-100">Match Fixtures</h3>
                            {localTournamentData.settings.categories.length > 0 && (
                                <div className="flex items-center space-x-2">
                                    <label htmlFor="fixtureCategoryFilter" className="text-slate-300 text-sm">Filter by Category:</label>
                                    <select
                                        id="fixtureCategoryFilter"
                                        value={selectedFixtureFilterCategory}
                                        onChange={(e) => setSelectedFixtureFilterCategory(e.target.value)}
                                        className="py-2 px-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 text-white sm:text-sm"
                                        aria-label="Filter fixtures by category"
                                    >
                                        <option value="All">All Categories</option>
                                        {localTournamentData.settings.categories.map(category => (
                                            <option key={category} value={category}>{category}</option>
                                        ))}
                                    </select>
                                </div>
                            )}

                            {selectedFixtureFilterCategory !== 'All' && localTournamentData.fixtures.length > 0 && (
                                <div className="flex items-center space-x-2">
                                    <label htmlFor="fixtureGroupFilter" className="text-slate-300 text-sm">Filter by Group:</label>
                                    <select
                                        id="fixtureGroupFilter"
                                        value={selectedFixtureFilterGroup}
                                        onChange={(e) => setSelectedFixtureFilterGroup(e.target.value)}
                                        className="py-2 px-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 text-white sm:text-sm"
                                        aria-label="Filter fixtures by group"
                                    >
                                        <option value="All">All Groups</option>
                                        {localTournamentData.fixtures
                                            .filter(f => f.category === selectedFixtureFilterCategory)
                                            .flatMap(f => f.groups)
                                            .map(group => (
                                                <option key={group.id} value={group.name}>{group.name}</option>
                                            ))
                                        }
                                    </select>
                                </div>
                            )}
                        </div>

                        {categoryFilteredFixtures.length === 0 ? (
                            <p className="text-slate-400">No fixtures published yet or no fixtures match the selected category/group.</p>
                        ) : (
                            <div className="space-y-6">
                                {categoryFilteredFixtures.map(catFix => {
                                    // Apply group filter *within* this category fixture
                                    const displayGroups = selectedFixtureFilterGroup === 'All'
                                        ? catFix.groups
                                        : catFix.groups.filter(g => g.name === selectedFixtureFilterGroup);

                                    const displayMatches = selectedFixtureFilterGroup === 'All'
                                        ? catFix.matches
                                        : catFix.matches.filter(m => m.groupName === selectedFixtureFilterGroup);
                                    
                                    // Only render this category's fixtures if there are groups to display
                                    if (displayGroups.length === 0) return null;

                                    return (
                                        <div key={`${catFix.category}-${catFix.tournamentType}`} className="bg-slate-700 p-4 rounded-lg">
                                            <h4 className="text-xl font-semibold text-slate-100 mb-3">{catFix.category} - {catFix.tournamentType}</h4>
                                            {displayGroups.map(group => ( // Loop through potentially filtered groups
                                                <div key={group.id} className="mb-4">
                                                    <h5 className="font-bold text-slate-200 mb-2">{group.name}</h5>
                                                    <p className="text-sm text-slate-300 mb-3">Players: {group.playerIds.map(getPlayerName).join(', ')}</p>
                                                    <div className="overflow-x-auto">
                                                        <table className="min-w-full divide-y divide-slate-600" aria-label={`Matches for ${group.name}`}>
                                                            <thead className="bg-slate-800">
                                                                <tr>
                                                                    <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                                        Match
                                                                    </th>
                                                                    <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                                        Player 1
                                                                    </th>
                                                                    <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                                        Player 2
                                                                    </th>
                                                                    <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                                        Score
                                                                    </th>
                                                                    <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                                        Status
                                                                    </th>
                                                                </tr>
                                                            </thead>
                                                            <tbody className="bg-slate-700 divide-y divide-slate-600">
                                                                {displayMatches // Use displayMatches here
                                                                    .filter(match => // Still need to filter matches for the current group
                                                                        match.groupName === group.name && // Ensure match belongs to this group
                                                                        group.playerIds.includes(match.player1Id) && group.playerIds.includes(match.player2Id)
                                                                    )
                                                                    .map(match => {
                                                                        const isWalkoverP1 = match.status === 'completed' && match.score1 === 1 && match.score2 === 0;
                                                                        const isWalkoverP2 = match.status === 'completed' && match.score1 === 0 && match.score2 === 1;
                                                                        const isDisqualifiedMatch = match.status === 'completed' && match.score1 === 0 && match.score2 === 0;
                                                                        const isRegularCompleted = match.status === 'completed' && !isWalkoverP1 && !isWalkoverP2 && !isDisqualifiedMatch;

                                                                        let rowBorderClass = '';
                                                                        if (isDisqualifiedMatch) {
                                                                            rowBorderClass = 'border-l-4 border-red-500';
                                                                        } else if (isWalkoverP1 || isWalkoverP2) {
                                                                            rowBorderClass = 'border-l-4 border-yellow-500';
                                                                        } else if (isRegularCompleted) {
                                                                            rowBorderClass = 'border-l-4 border-green-500';
                                                                        }

                                                                        // Determine status text and color based on specific conditions
                                                                        let statusText = match.status.charAt(0).toUpperCase() + match.status.slice(1);
                                                                        let statusColorClass = 'bg-slate-600'; // Default for scheduled

                                                                        if (isDisqualifiedMatch) {
                                                                            statusText = 'Disqualified';
                                                                            statusColorClass = 'bg-red-600';
                                                                        } else if (isWalkoverP1) {
                                                                            statusText = 'Walkover (P1)';
                                                                            statusColorClass = 'bg-yellow-600';
                                                                        } else if (isWalkoverP2) {
                                                                            statusText = 'Walkover (P2)';
                                                                            statusColorClass = 'bg-yellow-600';
                                                                        } else if (isRegularCompleted) {
                                                                            statusText = 'Completed';
                                                                            statusColorClass = 'bg-green-600';
                                                                        } else if (match.status === 'in-progress') {
                                                                            statusColorClass = 'bg-sky-600';
                                                                        }


                                                                        const scoreDisplay = () => {
                                                                            if (isWalkoverP1) return <span className="font-bold text-yellow-300">1 - 0 (Walkover P1)</span>;
                                                                            if (isWalkoverP2) return <span className="font-bold text-yellow-300">0 - 1 (Walkover P2)</span>;
                                                                            if (isDisqualifiedMatch) return <span className="font-bold text-red-300">0 - 0 (Disqualified)</span>;
                                                                            if (isRegularCompleted && match.score1 !== null && match.score2 !== null) return <span className="font-bold text-green-300">{match.score1} - {match.score2}</span>;
                                                                            return 'N/A';
                                                                        };

                                                                        return (
                                                                            <tr key={match.id} className={`hover:bg-slate-600 ${rowBorderClass}`}>
                                                                                <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-200">
                                                                                    {getPlayerName(match.player1Id)} vs {getPlayerName(match.player2Id)}
                                                                                </td>
                                                                                <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-300">
                                                                                    {getPlayerName(match.player1Id)}
                                                                                </td>
                                                                                <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-300">
                                                                                    {getPlayerName(match.player2Id)}
                                                                                </td>
                                                                                <td className="px-4 py-3 whitespace-nowrap text-sm">
                                                                                    {scoreDisplay()}
                                                                                </td>
                                                                                <td className="px-4 py-3 whitespace-nowrap text-sm">
                                                                                    <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${statusColorClass} text-white`}>
                                                                                        {statusText}
                                                                                        {isRegularCompleted && (
                                                                                            <svg className="ml-1 h-3 w-3" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                                                                                <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                                                                                            </svg>
                                                                                        )}
                                                                                    </span>
                                                                                </td>
                                                                            </tr>
                                                                        );
                                                                    })}
                                                            </tbody>
                                                        </table>
                                                    </div>
                                                </div>
                                            ))}
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                    </div>
                    {localTournamentData && <PlayerChat tournamentData={localTournamentData} />}
                </div>
            );
        };

        const PlayerChat = ({ tournamentData }) => {
            const [messages, setMessages] = useState([]);
            const [input, setInput] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const chatContainerRef = useRef(null);

            // Scroll to bottom on new message
            useEffect(() => {
                if (chatContainerRef.current) {
                    chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
                }
            }, [messages]);

            // Helper to get player name by ID for function calls
            const getPlayerNameById = useCallback((playerId, playersArray) => {
                const player = playersArray.find(p => p.id === playerId);
                return player ? player.name : `Unknown Player`;
            }, []);

            // Helper functions that the model can 'call'
            const tournamentFunctions = useRef({
                // Placeholder to allow getPlayerNameById to be used by other functions
                getPlayerNameById: (playerId) => getPlayerNameById(playerId, tournamentData.players),

                getTournamentOverview: () => {
                    if (!tournamentData || !tournamentData.settings) {
                        return "Tournament data is not fully available.";
                    }
                    const settings = tournamentData.settings;
                    const numPlayers = tournamentData.players ? tournamentData.players.length : 0;
                    const numMatches = tournamentData.fixtures ? tournamentData.fixtures.flatMap(f => f.matches).length : 0;
                    return `The tournament "${settings.name}" has ${numPlayers} registered players and ${numMatches} matches planned/played. Categories: ${settings.categories.join(', ')}. Types: ${settings.types.join(', ')}.`;
                },

                listPlayers: (category) => {
                    if (!tournamentData || !tournamentData.players) return "Player data is not available.";
                    
                    const filtered = tournamentData.players.filter(p =>
                        !category || p.categories.includes(category)
                    );
                    if (filtered.length === 0) {
                        return `No players found matching the category "${category || 'any'}".`;
                    }
                    return `Players found: ${filtered.map(p => p.name).join(', ')}.`;
                },

                getMatchDetails: (player1Name, player2Name) => {
                    if (!tournamentData || !tournamentData.players || !tournamentData.fixtures) {
                        return "Match or player data is not available.";
                    }

                    const p1 = tournamentData.players.find(p => p.name.toLowerCase() === player1Name.toLowerCase());
                    const p2 = tournamentData.players.find(p => p.name.toLowerCase() === player2Name.toLowerCase());

                    if (!p1 || !p2) {
                        return `Could not find one or both players. Please ensure full names are provided.`;
                    }

                    for (const catFix of tournamentData.fixtures) {
                        for (const match of catFix.matches) {
                            if ((match.player1Id === p1.id && match.player2Id === p2.id) ||
                                (match.player1Id === p2.id && match.player2Id === p1.id)) {
                                const p1MatchName = getPlayerNameById(match.player1Id, tournamentData.players);
                                const p2MatchName = getPlayerNameById(match.player2Id, tournamentData.players);
                                const score = match.score1 !== null && match.score2 !== null ? `${match.score1} - ${match.score2}` : 'Not available';
                                const statusText = match.status.replace(/_/g, ' ');
                                return `Match: ${p1MatchName} vs ${p2MatchName} in ${catFix.category} (${catFix.tournamentType}). Score: ${score}. Status: ${statusText}. Group: ${match.groupName || 'N/A'}.`;
                            }
                        }
                    }
                    return `No match found between ${player1Name} and ${player2Name}.`;
                }
            }).current; // Use useRef to keep functions stable across renders

            const handleSendMessage = async () => {
                if (input.trim() === '') return;
                if (!process.env.API_KEY || process.env.API_KEY === 'YOUR_GEMINI_API_KEY') {
                    setError('Gemini API key is not configured. Please contact the administrator.');
                    return;
                }

                const userMessage = { role: 'user', text: input.trim() };
                setMessages(prev => [...prev, userMessage]);
                setInput('');
                setIsLoading(true);
                setError(null);

                try {
                    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

                    const chat = ai.chats.create({
                        model: 'gemini-2.5-flash',
                        tools: [{
                            functionDeclarations: [
                                {
                                    name: 'getTournamentOverview',
                                    parameters: {
                                        type: Type.OBJECT,
                                        description: 'Get a summary overview of the tournament, including name, player count, match count, categories, and types.',
                                        properties: {},
                                    },
                                },
                                {
                                    name: 'listPlayers',
                                    parameters: {
                                        type: Type.OBJECT,
                                        description: 'List all registered players or players filtered by a specific category.',
                                        properties: {
                                            category: {
                                                type: Type.STRING,
                                                description: 'Optional: Filter players by category (e.g., "Open", "30+", "40+").',
                                                enum: tournamentData?.settings?.categories || [], // Provide valid categories as enum if available
                                            },
                                        },
                                    },
                                },
                                {
                                    name: 'getMatchDetails',
                                    parameters: {
                                        type: Type.OBJECT,
                                        description: 'Get details (score, status, category, type) for a specific match between two players.',
                                        properties: {
                                            player1Name: { type: Type.STRING, description: 'The full name of the first player.' },
                                            player2Name: { type: Type.STRING, description: 'The full name of the second player.' },
                                        },
                                        required: ['player1Name', 'player2Name'],
                                    },
                                },
                            ]
                        }, { googleSearch: {} }] // Add Google Search for general queries
                    });

                    let currentResponse;
                    let turnMessage = userMessage.text;
                    let iterationCount = 0;
                    const MAX_ITERATIONS = 5; // Prevent infinite loops in tool calling

                    while (iterationCount < MAX_ITERATIONS) {
                        currentResponse = await chat.sendMessage({ message: turnMessage });
                        turnMessage = null; // Clear turnMessage for subsequent tool calls in the same turn

                        if (currentResponse.functionCalls && currentResponse.functionCalls.length > 0) {
                            const toolResponses = [];
                            for (const fc of currentResponse.functionCalls) {
                                let result;
                                try {
                                    if (tournamentFunctions[fc.name]) {
                                        result = tournamentFunctions[fc.name](...Object.values(fc.args));
                                    } else {
                                        result = `Error: Unknown function called: ${fc.name}`;
                                        console.warn(`Model attempted to call unknown function: ${fc.name}`);
                                    }
                                } catch (funcErr) {
                                    result = `Error executing function ${fc.name}: ${funcErr.message}`;
                                    console.error(`Error in function execution for ${fc.name}:`, funcErr);
                                }
                                toolResponses.push({
                                    id: fc.id,
                                    name: fc.name,
                                    response: { result: result },
                                });
                            }
                            // Send tool responses back to the model for it to generate the final human-readable response
                            currentResponse = await chat.sendMessage({ toolResponses: toolResponses });
                            // The response from sending tool results is also a GenerateContentResponse
                            // Check again if it asks for more tools or provides text.
                            if (!currentResponse.functionCalls || currentResponse.functionCalls.length === 0) {
                                if (currentResponse.groundingMetadata?.groundingChunks) {
                                    const links = currentResponse.groundingMetadata.groundingChunks
                                        .filter(chunk => chunk.web && chunk.web.uri)
                                        .map(chunk => `[${chunk.web.title || 'Link'}](${chunk.web.uri})`)
                                        .join(', ');
                                    let modelText = currentResponse.text;
                                    if (links) {
                                        modelText += `\n\n_Sources: ${links}_`;
                                    }
                                    setMessages(prev => [...prev, { role: 'model', text: modelText }]);
                                } else {
                                    setMessages(prev => [...prev, { role: 'model', text: currentResponse.text }]);
                                }
                                break; // Exit loop, got final response
                            }
                        } else if (currentResponse.groundingMetadata?.groundingChunks) {
                            // Handle Google Search results directly (if no functions were called)
                            const links = currentResponse.groundingMetadata.groundingChunks
                                .filter(chunk => chunk.web && chunk.web.uri)
                                .map(chunk => `[${chunk.web.title || 'Link'}](${chunk.web.uri})`)
                                .join(', ');
                            let modelText = currentResponse.text;
                            if (links) {
                                modelText += `\n\n_Sources: ${links}_`;
                            }
                            setMessages(prev => [...prev, { role: 'model', text: modelText }]);
                            break; // Exit loop, got final response
                        } else {
                            // No function calls or grounding metadata, direct text response
                            setMessages(prev => [...prev, { role: 'model', text: currentResponse.text }]);
                            break; // Exit loop, got final response
                        }
                        iterationCount++;
                    }

                    if (iterationCount >= MAX_ITERATIONS) {
                        setMessages(prev => [...prev, { role: 'model', text: 'Error: Conversation exceeded maximum turns for tool calls. Please try rephrasing.' }]);
                    }


                } catch (err) {
                    console.error('Gemini API Error:', err);
                    setError('Failed to get a response from the AI. Please try again later.');
                    setMessages(prev => [...prev, { role: 'model', text: 'Error: Could not retrieve response.' }]);
                } finally {
                    setIsLoading(false);
                }
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSendMessage();
                }
            };

            return (
                <div className="bg-slate-800 p-6 rounded-lg shadow-lg">
                    <h3 className="text-2xl font-semibold text-slate-100 mb-4">Tournament Chat Assistant</h3>
                    <div ref={chatContainerRef} className="h-80 overflow-y-auto border border-slate-700 rounded-md p-4 mb-4 bg-slate-900 scrollbar-thin scrollbar-thumb-slate-600 scrollbar-track-slate-800">
                        {messages.length === 0 ? (
                            <p className="text-slate-500 italic">Ask me anything about the tournament (e.g., "Who are the players?", "What is the score of John Doe vs Jane Smith?", "Tell me about the tournament").</p>
                        ) : (
                            messages.map((msg, index) => (
                                <div key={index} className={`mb-2 p-3 rounded-lg flex flex-col ${msg.role === 'user' ? 'bg-sky-900/50 self-end ml-auto max-w-[80%] text-right items-end' : 'bg-slate-700/50 self-start mr-auto max-w-[80%] text-left items-start'}`}>
                                    <span className={`font-semibold text-xs mb-1 ${msg.role === 'user' ? 'text-sky-300' : 'text-slate-300'}`}>{msg.role === 'user' ? 'You' : 'Assistant'}</span>
                                    <p className="text-slate-200 text-sm whitespace-pre-wrap">{msg.text}</p>
                                </div>
                            ))
                        )}
                        {isLoading && (
                            <div className="flex items-center justify-center p-2">
                                <svg className="animate-spin h-5 w-5 text-sky-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                            </div>
                        )}
                         {error && <p className="text-red-400 text-sm mt-2" role="alert">{error}</p>}
                    </div>
                    <div className="flex gap-2">
                        <textarea
                            className="flex-grow py-2 px-4 rounded-lg bg-slate-700 border border-slate-600 focus:outline-none focus:ring-sky-500 focus:border-sky-500 text-white resize-none"
                            placeholder="Ask a question..."
                            value={input}
                            onChange={(e) => setInput(e.target.value)}
                            onKeyDown={handleKeyDown}
                            disabled={isLoading}
                            rows={1}
                            style={{ minHeight: '40px', maxHeight: '120px' }}
                            aria-label="Chat input"
                        />
                        <button
                            onClick={handleSendMessage}
                            className="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                            disabled={isLoading || input.trim() === ''}
                            aria-label="Send message"
                        >
                            Send
                        </button>
                    </div>
                </div>
            );
        };


        // --- Main Application Component ---

        const App = () => {
            const [isAdminLoggedIn, setIsAdminLoggedIn] = useState(getLocalStorage(LS_ADMIN_LOGGED_IN, false));
            const [viewMode, setViewMode] = useState(isAdminLoggedIn ? 'admin' : 'player'); // 'admin-login', 'admin', 'player'
            const [isPublishing, setIsPublishing] = useState(false); // Lifted state

            const [tournamentData, setTournamentData] = useState(() => {
                const storedData = getLocalStorage(LS_TOURNAMENT_DATA, null);
                // Ensure isPublished is always present and default settings are consistent
                const defaultTournamentData = {
                    settings: {
                        name: 'New Tournament',
                        types: [TournamentType.MEN_SINGLES],
                        categories: [PlayerCategory.OPEN],
                    },
                    players: [],
                    fixtures: [],
                    isPublished: false,
                };
                if (storedData) {
                    // Deep merge for fixtures to ensure history array and other defaults
                    const mergedFixtures = (storedData.fixtures || []).map(catFix => ({
                        ...catFix,
                        groups: catFix.groups || [], // Ensure groups array exists
                        matches: (catFix.matches || []).map(match => ({
                            history: match.history || [], // Ensure history exists and is an array
                            ...match, // Existing match properties override
                        }))
                    }));

                    return {
                        ...defaultTournamentData, // Ensure default structure if parts are missing
                        ...storedData,
                        settings: { ...defaultTournamentData.settings, ...storedData.settings }, // Merge settings
                        isPublished: storedData.hasOwnProperty('isPublished') ? storedData.isPublished : false, // Ensure flag
                        fixtures: mergedFixtures // Use the merged fixtures
                    };
                }
                return defaultTournamentData;
            });

            // Persist admin login state
            useEffect(() => {
                setLocalStorage(LS_ADMIN_LOGGED_IN, isAdminLoggedIn);
            }, [isAdminLoggedIn]);

            // Persist tournament data
            useEffect(() => {
                console.log('App: useEffect - Saving tournamentData to localStorage. isPublished:', tournamentData.isPublished, 'Data:', tournamentData);
                setLocalStorage(LS_TOURNAMENT_DATA, tournamentData);
            }, [tournamentData]);

            const handleAdminLogin = () => {
                setIsAdminLoggedIn(true);
                setViewMode('admin');
            };

            const handleAdminLogout = () => {
                setIsAdminLoggedIn(false);
                setViewMode('admin-login');
            };

            const handlePublishTournament = () => {
                console.log('App: handlePublishTournament - START. Current tournamentData:', JSON.stringify(tournamentData));

                // Perform checks before publishing (these should ideally match `canPublish` in AdminDashboard)
                if (tournamentData.settings.name.trim() === '') {
                    alert('Publish failed: Please complete tournament name in settings.');
                    return;
                }
                if (tournamentData.settings.types.length === 0) {
                    alert('Publish failed: Please select at least one tournament type in settings.');
                    return;
                }
                if (tournamentData.settings.categories.length === 0) {
                    alert('Publish failed: Please select at least one player category in settings.');
                    return;
                }
                if (tournamentData.players.length === 0) {
                    alert('Publish failed: Please add players.');
                    return;
                }
                if (tournamentData.fixtures.length === 0) {
                    alert('Publish failed: Please generate or upload fixtures.');
                    return;
                }
                
                const newState = { ...tournamentData, isPublished: true };
                setTournamentData(newState); // Update component state, which will trigger useEffect for persistence
                console.log('App: handlePublishTournament - END. newState.isPublished:', newState.isPublished, 'TournamentData after setTournamentData:', JSON.stringify(newState));
            };

            // Derived publish status for AppHeader
            const publishStatus = isPublishing
                ? 'Publishing...'
                : tournamentData.isPublished
                    ? 'Published'
                    : 'Draft';

            return (
                <div className="min-h-screen bg-slate-900 text-slate-200">
                    <AppHeader
                        isAdmin={isAdminLoggedIn}
                        onLogout={handleAdminLogout}
                        viewMode={viewMode}
                        setViewMode={setViewMode}
                        publishStatus={publishStatus} // Pass derived status
                    />
                    <main className="container mx-auto p-4 sm:p-6 lg:p-8">
                        {viewMode === 'admin-login' && !isAdminLoggedIn && (
                            <AdminLogin onLogin={handleAdminLogin} />
                        )}
                        {viewMode === 'admin' && isAdminLoggedIn && (
                            <AdminDashboard
                                tournamentData={tournamentData}
                                setTournamentData={setTournamentData}
                                onPublish={handlePublishTournament}
                                isPublishing={isPublishing} // Pass lifted state
                                setIsPublishing={setIsPublishing} // Pass setter for lifted state
                            />
                        )}
                        {viewMode === 'player' && (
                            <PlayerView />
                        )}
                    </main>
                </div>
            );
        };

        // --- Use modern createRoot API ---
        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>