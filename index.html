
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Management System</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load React and ReactDOM from CDNs -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Load Babel for JSX transformation in the browser. NOTE: This impacts performance due to client-side transpilation. -->
    <style>
        body {
            background-color: #0f172a; /* bg-slate-900 */
            color: #e2e8f0; /* text-slate-200 */
            font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
        }
        #root:empty::before {
            content: "Loading Application...";
            color: #cbd5e1; /* text-slate-300 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-size: 1.5rem;
        }

        /* Basic form input styling */
        input[type="text"],
        input[type="number"],
        input[type="password"],
        select,
        textarea {
            background-color: #334155; /* bg-slate-700 */
            border-color: #475569; /* border-slate-600 */
            color: #e2e8f0; /* text-slate-200 */
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem; /* rounded-md */
            width: 100%;
            transition: all 0.2s ease-in-out;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        input[type="password"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #0ea5e9; /* border-sky-500 */
            box-shadow: 0 0 0 1px #0ea5e9; /* ring-sky-500 */
        }

        input[type="checkbox"] {
            accent-color: #0ea5e9; /* sky-600 */
        }
        
        /* File input custom styling */
        input[type="file"]::file-selector-button {
            background-color: #0ea5e9; /* bg-sky-600 */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem; /* rounded-md */
            border: none;
            cursor: pointer;
            margin-right: 1rem;
            transition: background-color 0.2s ease-in-out;
        }

        input[type="file"]::file-selector-button:hover {
            background-color: #0284c7; /* hover:bg-sky-700 */
        }

        input[type="file"] {
            border: 1px solid #475569; /* border-slate-600 */
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.25rem;
        }


        /* Table styling (prose classes removed as they are not needed for custom tables) */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border-radius: 0.5rem;
            overflow: hidden;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #334155; /* border-slate-700 */
            color: #cbd5e1; /* text-slate-300 */
        }
        th {
            background-color: #0f172a; /* bg-slate-900 */
            font-weight: 600;
            color: #e2e8f0; /* text-slate-200 */
            text-transform: uppercase;
            font-size: 0.75rem;
        }
        tr:nth-child(even) {
            background-color: #1e293b; /* bg-slate-800 */
        }
        tr:hover {
            background-color: #334155; /* bg-slate-700 */
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Start of Babel script
        const { useState, useCallback, useEffect, useRef } = React;
        const ReactDOM = window.ReactDOM;

        // --- Type Definitions (as JS objects/enums) ---
        const TournamentType = {
            MEN_SINGLES: 'Men Singles',
            MEN_DOUBLES: 'Men Doubles',
            WOMEN_SINGLES: 'Women Singles',
            WOMEN_DOUBLES: 'Women Doubles',
            MIXED_DOUBLES: 'Mixed Doubles',
        };

        const PlayerCategory = {
            OPEN: 'Open',
            THIRTY_PLUS: '30+',
            FORTY_PLUS: '40+',
            FIFTY_PLUS: '50+',
            SIXTY_PLUS: '60+',
            SEVENTY_PLUS: '70+',
        };

        // --- Local Storage Keys ---
        const LS_TOURNAMENT_DATA = 'tournamentData';
        const LS_ADMIN_LOGGED_IN = 'adminLoggedIn';

        // --- Helper Functions ---

        // Local Storage Management
        const getLocalStorage = (key, defaultValue) => {
            try {
                const item = localStorage.getItem(key);
                // console.log(`[LocalStorage] get item "${key}": raw string:`, item); // Excessive logging
                if (item === null) {
                    // console.log(`[LocalStorage] get item "${key}": no item found, returning default.`, defaultValue); // Excessive logging
                    return defaultValue;
                }
                const parsedItem = JSON.parse(item);
                // console.log(`[LocalStorage] get item "${key}": parsed:`, parsedItem); // Excessive logging
                return parsedItem;
            } catch (error) {
                console.error(`[LocalStorage] Error reading or parsing from localStorage key "${key}":`, error);
                return defaultValue;
            }
        };

        const setLocalStorage = (key, value) => {
            try {
                const stringifiedValue = JSON.stringify(value);
                // console.log(`[LocalStorage] set item "${key}": stringified:`, stringifiedValue); // Excessive logging
                localStorage.setItem(key, stringifiedValue);
                // console.log(`[LocalStorage] set item "${key}": successfully saved.`); // Excessive logging
            } catch (error) {
                console.error(`[LocalStorage] Error writing to localStorage key "${key}":`, error);
                if (error instanceof DOMException && (error.code === 22 || error.name === 'QuotaExceededError')) {
                    alert('Local storage limit exceeded. Please clear some data or use a different browser.');
                } else if (error instanceof DOMException && error.name === 'SecurityError') {
                    alert('Local storage access denied. Please ensure you are not in private browsing mode.');
                }
            }
        };

        const generateUUID = () => {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        };

        // CSV Parsing (simplified for in-browser use)
        const parseCsv = (csvString) => {
            const lines = csvString.trim().split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) return [];

            const headers = lines[0].split(',').map(h => h.trim());
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                if (values.length !== headers.length) {
                    console.warn(`Skipping malformed row: ${lines[i]} (expected ${headers.length} columns, got ${values.length})`);
                    continue;
                }
                let row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index];
                });
                data.push(row);
            }
            return data;
        };

        // Fixture Generation Logic (Round Robin)
        const generateRoundRobinMatches = (playerIds, category, tournamentType, groupName) => {
            if (playerIds.length < 2) return [];
            const matches = [];
            for (let i = 0; i < playerIds.length; i++) {
                for (let j = i + 1; j < playerIds.length; j++) {
                    matches.push({
                        id: generateUUID(),
                        category: category,
                        tournamentType: tournamentType,
                        groupName: groupName,
                        player1Id: playerIds[i],
                        player2Id: playerIds[j],
                        score1: null,
                        score2: null,
                        status: 'scheduled',
                    });
                }
            }
            return matches;
        };

        const groupPlayersRandomly = (playersInCategories, minGroupSize, maxGroupSize) => {
            const finalGroupedPlayers = {};

            for (const category in playersInCategories) {
                finalGroupedPlayers[category] = {};
                for (const type in playersInCategories[category]) {
                    const playerIds = [...playersInCategories[category][type]];
                    const totalPlayers = playerIds.length;

                    // 1. Basic Validation: Not enough players for even one minimum-sized group
                    if (totalPlayers < minGroupSize) {
                        console.warn(`Not enough players for ${category} - ${type}. Need at least ${minGroupSize}, found ${totalPlayers}. Skipping grouping.`);
                        finalGroupedPlayers[category][type] = [];
                        continue;
                    }

                    // 2. Determine valid range for number of groups (k)
                    const minAllowedGroups = Math.ceil(totalPlayers / maxGroupSize);
                    const maxAllowedGroups = Math.floor(totalPlayers / minGroupSize);

                    if (minAllowedGroups > maxAllowedGroups) {
                        console.warn(`Impossible to form valid groups for ${category} - ${type} with ${totalPlayers} players (min: ${minGroupSize}, max: ${maxGroupSize}). Constraints cannot be met.`);
                        finalGroupedPlayers[category][type] = [];
                        continue;
                    }

                    // 3. Choose number of groups (k) within the valid range.
                    // We choose the smallest possible number of groups (minAllowedGroups) to make groups as large as possible
                    // (closer to maxGroupSize), which minimizes the total number of matches.
                    const numGroups = minAllowedGroups; 
                    
                    const shuffledPlayerIds = playerIds.sort(() => 0.5 - Math.random()); // Simple shuffle

                    const groups = Array.from({ length: numGroups }, (_, i) => ({
                        id: generateUUID(),
                        name: `Group ${String.fromCharCode(65 + i)}`,
                        playerIds: [],
                    }));

                    // 4. Distribute players round-robin into the determined number of groups
                    for (let i = 0; i < totalPlayers; i++) {
                        groups[i % numGroups].playerIds.push(shuffledPlayerIds[i]);
                    }

                    // 5. Final Validation (should pass if numGroups was chosen correctly)
                    const invalidGroups = groups.filter(g => g.playerIds.length < minGroupSize || g.playerIds.length > maxGroupSize);
                    if (invalidGroups.length > 0) {
                        console.error(`Internal Grouping Error: Groups formed outside valid size for ${category} - ${type}:`, invalidGroups);
                        // This indicates a bug in the numGroups calculation or distribution logic that needs fixing.
                        finalGroupedPlayers[category][type] = []; 
                    } else {
                        finalGroupedPlayers[category][type] = groups;
                    }
                }
            }
            return finalGroupedPlayers;
        };


        // --- UI Components ---

        const AppHeader = ({ isAdmin, onLogout, viewMode, setViewMode, publishStatus }) => {
            const LogoIcon = () => (
                <svg xmlns="http://www.w3.org/2000/svg" className="h-8 w-8 text-sky-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                    <path strokeLinecap="round" strokeLinejoin="round" d="M9.75 3.104l-2.286 9.144a3.75 3.75 0 003.75 4.498h1.5A3.75 3.75 0 0016.5 12.25l-2.286-9.144a3.75 3.75 0 00-4.464 0z" />
                    <path strokeLinecap="round" strokeLinejoin="round" d="M12 21a9.002 9.002 0 008.13-5.253M3.87 15.747A9.002 9.002 0 0012 21" />
                </svg>
            );

            const statusColor = publishStatus === 'Published' ? 'bg-green-600' : publishStatus === 'Publishing...' ? 'bg-yellow-600' : 'bg-slate-600';
            const statusText = publishStatus;

            return (
                <header className="bg-slate-900/70 backdrop-blur-lg p-4 border-b border-slate-700 sticky top-0 z-10">
                    <div className="container mx-auto flex items-center justify-between gap-4">
                        <div className="flex items-center gap-4">
                            <LogoIcon />
                            <h1 className="text-2xl font-bold text-slate-100 tracking-tight">
                                Tournament Manager
                            </h1>
                            {isAdmin && (
                                <span className={`ml-3 px-3 py-1 text-xs font-semibold text-white rounded-full ${statusColor}`} aria-label={`Publishing status: ${statusText}`}>
                                    {statusText}
                                </span>
                            )}
                        </div>
                        {isAdmin && (
                            <div className="flex items-center gap-4">
                                <button
                                    onClick={() => setViewMode('admin')}
                                    className={`py-2 px-4 rounded-md text-sm font-medium transition-colors ${viewMode === 'admin' ? 'bg-sky-600 text-white' : 'text-slate-300 hover:bg-slate-700'}`}
                                    aria-label="Admin Dashboard"
                                >
                                    Admin Dashboard
                                </button>
                                <button
                                    onClick={() => setViewMode('player')}
                                    className={`py-2 px-4 rounded-md text-sm font-medium transition-colors ${viewMode === 'player' ? 'bg-sky-600 text-white' : 'text-slate-300 hover:bg-slate-700'}`}
                                    aria-label="Player View"
                                >
                                    Player View
                                </button>
                                <button
                                    onClick={onLogout}
                                    className="py-2 px-4 bg-red-600 hover:bg-red-700 rounded-md text-sm font-medium text-white transition-colors"
                                    aria-label="Logout"
                                >
                                    Logout
                                </button>
                            </div>
                        )}
                         {!isAdmin && (
                            <div className="flex items-center gap-4">
                                <button
                                    onClick={() => setViewMode('admin-login')}
                                    className={`py-2 px-4 rounded-md text-sm font-medium transition-colors ${viewMode === 'admin-login' ? 'bg-sky-600 text-white' : 'text-slate-300 hover:bg-slate-700'}`}
                                    aria-label="Admin Login"
                                >
                                    Admin Login
                                </button>
                                <button
                                    onClick={() => setViewMode('player')}
                                    className={`py-2 px-4 rounded-md text-sm font-medium transition-colors ${viewMode === 'player' ? 'bg-sky-600 text-white' : 'text-slate-300 hover:bg-slate-700'}`}
                                    aria-label="Player View"
                                >
                                    Player View
                                </button>
                            </div>
                        )}
                    </div>
                </header>
            );
        };

        const AdminLogin = ({ onLogin }) => {
            const [username, setUsername] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                setError('');
                if (username === 'admin' && password === 'password') {
                    onLogin();
                } else {
                    setError('Invalid username or password.');
                }
            };

            return (
                <div className="flex items-center justify-center min-h-[calc(100vh-80px)]">
                    <form onSubmit={handleSubmit} className="bg-slate-800 p-8 rounded-lg shadow-lg w-full max-w-md">
                        <h2 className="text-3xl font-bold text-slate-100 mb-6 text-center">Admin Login</h2>
                        {error && <p className="text-red-400 text-center mb-4" role="alert">{error}</p>}
                        <div className="mb-4">
                            <label htmlFor="username" className="block text-slate-300 text-sm font-bold mb-2">
                                Username
                            </label>
                            <input
                                type="text"
                                id="username"
                                className="shadow appearance-none border rounded w-full py-2 px-3 text-slate-200 leading-tight focus:outline-none focus:shadow-outline bg-slate-700 border-slate-600 focus:border-sky-500 focus:ring-sky-500"
                                value={username}
                                onChange={(e) => setUsername(e.target.value)}
                                required
                                aria-label="Username"
                                autoCapitalize="off"
                                autoComplete="username"
                            />
                        </div>
                        <div className="mb-6">
                            <label htmlFor="password" className="block text-slate-300 text-sm font-bold mb-2">
                                Password
                            </label>
                            <input
                                type="password"
                                id="password"
                                className="shadow appearance-none border rounded w-full py-2 px-3 text-slate-200 mb-3 leading-tight focus:outline-none focus:shadow-outline bg-slate-700 border-slate-600 focus:border-sky-500 focus:ring-sky-500"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                required
                                aria-label="Password"
                                autoComplete="current-password"
                            />
                        </div>
                        <div className="flex items-center justify-between">
                            <button
                                type="submit"
                                className="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors"
                                aria-label="Sign In"
                            >
                                Sign In
                            </button>
                        </div>
                    </form>
                </div>
            );
        };

        const TournamentSetup = ({ settings, onSaveSettings }) => {
            const [tournamentName, setTournamentName] = useState(settings?.name || '');
            const [selectedTypes, setSelectedTypes] = useState(settings?.types || []);
            const [selectedCategories, setSelectedCategories] = useState(settings?.categories || []);

            useEffect(() => {
                setTournamentName(settings?.name || '');
                setSelectedTypes(settings?.types || []);
                setSelectedCategories(settings?.categories || []);
            }, [settings]);

            const handleTypeChange = (type) => {
                setSelectedTypes(prev =>
                    prev.includes(type) ? prev.filter(t => t !== type) : [...prev, type]
                );
            };

            const handleCategoryChange = (category) => {
                setSelectedCategories(prev =>
                    prev.includes(category) ? prev.filter(c => c !== category) : [...prev, category]
                );
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                if (tournamentName.trim() === '') {
                    alert('Tournament Name cannot be empty.');
                    return;
                }
                if (selectedTypes.length === 0) {
                    alert('Please select at least one Tournament Type.');
                    return;
                }
                if (selectedCategories.length === 0) {
                    alert('Please select at least one Player Category.');
                    return;
                }
                onSaveSettings({
                    name: tournamentName,
                    types: selectedTypes,
                    categories: selectedCategories,
                });
                alert('Tournament settings saved!');
            };

            return (
                <div className="bg-slate-800 p-6 rounded-lg shadow-lg mb-6">
                    <h3 className="text-xl font-semibold text-slate-100 mb-4">Tournament Settings</h3>
                    <form onSubmit={handleSubmit} className="space-y-4">
                        <div>
                            <label htmlFor="tournamentName" className="block text-slate-300 text-sm font-bold mb-2">
                                Tournament Name
                            </label>
                            <input
                                type="text"
                                id="tournamentName"
                                className="shadow appearance-none border rounded w-full py-2 px-3 text-slate-200 leading-tight focus:outline-none focus:shadow-outline bg-slate-700 border-slate-600 focus:border-sky-500 focus:ring-sky-500"
                                value={tournamentName}
                                onChange={(e) => setTournamentName(e.target.value)}
                                required
                                aria-required="true"
                                aria-label="Tournament Name"
                            />
                        </div>

                        <div>
                            <label className="block text-slate-300 text-sm font-bold mb-2">
                                Tournament Types <span className="text-red-400">*</span>
                            </label>
                            <div className="grid grid-cols-2 sm:grid-cols-3 gap-2" role="group" aria-labelledby="tournament-types-label">
                                {Object.values(TournamentType).map(type => (
                                    <label key={type} className="flex items-center text-slate-200">
                                        <input
                                            type="checkbox"
                                            checked={selectedTypes.includes(type)}
                                            onChange={() => handleTypeChange(type)}
                                            className="form-checkbox h-4 w-4 text-sky-600 bg-slate-700 border-slate-600 rounded focus:ring-sky-500"
                                            aria-label={type}
                                        />
                                        <span className="ml-2 text-sm">{type}</span>
                                    </label>
                                ))}
                            </div>
                        </div>

                        <div>
                            <label className="block text-slate-300 text-sm font-bold mb-2">
                                Player Categories <span className="text-red-400">*</span>
                            </label>
                            <div className="grid grid-cols-2 sm:grid-cols-4 gap-2" role="group" aria-labelledby="player-categories-label">
                                {Object.values(PlayerCategory).map(category => (
                                    <label key={category} className="flex items-center text-slate-200">
                                        <input
                                            type="checkbox"
                                            checked={selectedCategories.includes(category)}
                                            onChange={() => handleCategoryChange(category)}
                                            className="form-checkbox h-4 w-4 text-sky-600 bg-slate-700 border-slate-600 rounded focus:ring-sky-500"
                                            aria-label={category}
                                        />
                                        <span className="ml-2 text-sm">{category}</span>
                                    </label>
                                ))}
                            </div>
                        </div>

                        <button
                            type="submit"
                            className="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors"
                            aria-label="Save Tournament Settings"
                        >
                            Save Tournament Settings
                        </button>
                    </form>
                </div>
            );
        };

        const PlayerManagement = ({ players, tournamentSettings, onAddPlayer, onUpdatePlayer, onDeletePlayer, onAddPlayersFromCsv }) => {
            const [playerName, setPlayerName] = useState('');
            const [mobileNumber, setMobileNumber] = useState('');
            const [selectedPlayerCategories, setSelectedPlayerCategories] = useState([]);
            const [feePaid, setFeePaid] = useState(false);
            const [editPlayerId, setEditPlayerId] = useState(null);
            const csvFileInputRef = useRef(null);

            const handlePlayerCategoryChange = (category) => {
                setSelectedPlayerCategories(prev => {
                    if (prev.includes(category)) {
                        return prev.filter(c => c !== category);
                    } else if (prev.length < 2) { // Max 2 categories
                        return [...prev, category];
                    }
                    return prev;
                });
            };

            const resetForm = () => {
                setPlayerName('');
                setMobileNumber('');
                setSelectedPlayerCategories([]);
                setFeePaid(false);
                setEditPlayerId(null);
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                if (!playerName || !mobileNumber || selectedPlayerCategories.length === 0) {
                    alert('Please fill in all player details and select at least one category.');
                    return;
                }
                if (selectedPlayerCategories.some(cat => !tournamentSettings.categories.includes(cat))) {
                    alert('One or more selected categories are not defined in tournament settings. Please update tournament settings or select valid categories.');
                    return;
                }


                const playerWithSameMobile = players.find(p => p.mobile === mobileNumber && p.id !== editPlayerId);
                if (playerWithSameMobile) {
                    alert('A player with this mobile number already exists. Please use a unique mobile number or edit the existing player.');
                    return;
                }

                if (editPlayerId) {
                    onUpdatePlayer({
                        id: editPlayerId,
                        name: playerName,
                        mobile: mobileNumber,
                        categories: selectedPlayerCategories,
                        feePaid: feePaid,
                    });
                    alert('Player updated successfully!');
                } else {
                    onAddPlayer({
                        id: generateUUID(),
                        name: playerName,
                        mobile: mobileNumber,
                        categories: selectedPlayerCategories,
                        feePaid: feePaid,
                    });
                    alert('Player added successfully!');
                }
                resetForm();
            };

            const handleEdit = (player) => {
                setPlayerName(player.name);
                setMobileNumber(player.mobile);
                setSelectedPlayerCategories(player.categories);
                setFeePaid(player.feePaid);
                setEditPlayerId(player.id);
                window.scrollTo({ top: 0, behavior: 'smooth' }); // Scroll to top to make form visible
            };

            const handleCsvUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const csvString = event.target.result;
                        const parsedData = parseCsv(csvString);
                        
                        let playersToAdd = [];
                        let existingMobiles = new Set(players.map(p => p.mobile));
                        
                        // Define a mapping for CSV category numbers to enum values
                        const csvCategoryMap = {
                            'Open': PlayerCategory.OPEN,
                            '30': PlayerCategory.THIRTY_PLUS,
                            '40': PlayerCategory.FORTY_PLUS,
                            '50': PlayerCategory.FIFTY_PLUS,
                            '60': PlayerCategory.SIXTY_PLUS,
                            '70': PlayerCategory.SEVENTY_PLUS,
                            '30+': PlayerCategory.THIRTY_PLUS, // Also handle if CSV already has '+'
                            '40+': PlayerCategory.FORTY_PLUS,
                            '50+': PlayerCategory.FIFTY_PLUS,
                            '60+': PlayerCategory.SIXTY_PLUS,
                            '70+': PlayerCategory.SEVENTY_PLUS,
                        };

                        parsedData.forEach(row => {
                            // Corrected to use 'MobileNumber' and 'Categories' based on the image and warnings
                            const name = row['Name'];
                            const mobile = row['MobileNumber']; 
                            const rawCategoryFromCsv = row['Categories']; 
                            const feePaidStatus = row['Paid(Y/N)']?.toUpperCase() === 'Y';

                            const categories = [];
                            if (rawCategoryFromCsv) {
                                // Map the raw CSV category to the actual PlayerCategory enum value
                                const mappedCategory = csvCategoryMap[rawCategoryFromCsv];

                                // Check if the mapped category is valid and included in tournament settings
                                if (mappedCategory && tournamentSettings.categories.includes(mappedCategory)) {
                                    categories.push(mappedCategory);
                                } else {
                                    console.warn(`Skipping category "${rawCategoryFromCsv}" from CSV: Invalid or not defined in tournament settings.`);
                                }
                            }

                            if (name && mobile && categories.length > 0) {
                                if (!existingMobiles.has(mobile)) {
                                    playersToAdd.push({
                                        id: generateUUID(),
                                        name: name,
                                        mobile: mobile,
                                        categories: categories, // Will contain 0 or 1 category from CSV
                                        feePaid: feePaidStatus,
                                    });
                                    existingMobiles.add(mobile); // Mark as added to avoid duplicates in current batch
                                } else {
                                    console.warn(`Skipping player ${name} (Mobile: ${mobile}) from CSV: Mobile number already exists.`);
                                }
                            } else {
                                console.warn(`Skipping CSV row due to missing required data or invalid categories: ${JSON.stringify(row)}`);
                            }
                        });

                        if (playersToAdd.length > 0) {
                            onAddPlayersFromCsv(playersToAdd);
                            alert(`${playersToAdd.length} players added from CSV successfully!`);
                        } else {
                            alert('No new valid players found in CSV to add or all players already exist.');
                        }
                        csvFileInputRef.current.value = ''; // Clear file input
                    };
                    reader.readAsText(file);
                }
            };

            const handleExportPlayersToCsv = () => {
                if (players.length === 0) {
                    alert('No players to export.');
                    return;
                }

                const headers = ["Player Name", "Mobile Number", "Category 1", "Category 2", "Fee Paid"];
                const csvRows = [headers.join(',')];

                players.forEach(player => {
                    // Extract up to two categories
                    const category1 = player.categories[0] || '';
                    const category2 = player.categories[1] || '';
                    const feePaidStatus = player.feePaid ? 'Y' : 'N';
                    
                    csvRows.push([
                        `"${player.name.replace(/"/g, '""')}"`, // Handle commas and quotes in name
                        `"${player.mobile}"`,
                        `"${category1}"`,
                        `"${category2}"`,
                        `"${feePaidStatus}"`
                    ].join(','));
                });

                const csvString = csvRows.join('\n');
                const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.setAttribute('href', url);
                link.setAttribute('download', 'registered_players.csv');
                link.click();
                URL.revokeObjectURL(url);
                alert('Players exported to CSV successfully!');
            };

            const groupedPlayers = players.reduce((acc, player) => {
                if (!acc[player.mobile]) {
                    acc[player.mobile] = [];
                }
                acc[player.mobile].push(player);
                return acc;
            }, {});

            return (
                <div className="bg-slate-800 p-6 rounded-lg shadow-lg mb-6">
                    <h3 className="text-xl font-semibold text-slate-100 mb-4">Manage Players</h3>

                    <form onSubmit={handleSubmit} className="space-y-4 mb-6">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label htmlFor="playerName" className="block text-slate-300 text-sm font-bold mb-2">
                                    Player Name <span className="text-red-400">*</span>
                                </label>
                                <input
                                    type="text"
                                    id="playerName"
                                    className="shadow appearance-none border rounded w-full py-2 px-3 text-slate-200 leading-tight focus:outline-none focus:shadow-outline bg-slate-700 border-slate-600 focus:border-sky-500 focus:ring-sky-500"
                                    value={playerName}
                                    onChange={(e) => setPlayerName(e.target.value)}
                                    required
                                    aria-required="true"
                                    aria-label="Player Name"
                                />
                            </div>
                            <div>
                                <label htmlFor="mobileNumber" className="block text-slate-300 text-sm font-bold mb-2">
                                    Mobile Number <span className="text-red-400">*</span>
                                </label>
                                <input
                                    type="text"
                                    id="mobileNumber"
                                    className="shadow appearance-none border rounded w-full py-2 px-3 text-slate-200 leading-tight focus:outline-none focus:shadow-outline bg-slate-700 border-slate-600 focus:border-sky-500 focus:ring-sky-500"
                                    value={mobileNumber}
                                    onChange={(e) => setMobileNumber(e.target.value)}
                                    required
                                    aria-required="true"
                                    aria-label="Mobile Number"
                                />
                            </div>
                        </div>

                        <div>
                            <label className="block text-slate-300 text-sm font-bold mb-2">
                                Categories (max 2) <span className="text-red-400">*</span>
                            </label>
                            <div className="grid grid-cols-2 sm:grid-cols-4 gap-2" role="group" aria-labelledby="player-categories-label">
                                {tournamentSettings.categories.length === 0 ? (
                                    <p className="text-slate-400 text-sm italic">Define tournament categories first in settings.</p>
                                ) : (
                                    tournamentSettings.categories.map(category => (
                                        <label key={category} className="flex items-center text-slate-200">
                                            <input
                                                type="checkbox"
                                                checked={selectedPlayerCategories.includes(category)}
                                                onChange={() => handlePlayerCategoryChange(category)}
                                                disabled={!selectedPlayerCategories.includes(category) && selectedPlayerCategories.length >= 2}
                                                className="form-checkbox h-4 w-4 text-sky-600 bg-slate-700 border-slate-600 rounded focus:ring-sky-500 disabled:opacity-50"
                                                aria-label={`Category ${category}`}
                                            />
                                            <span className="ml-2 text-sm">{category}</span>
                                        </label>
                                    ))
                                )}
                            </div>
                            {selectedPlayerCategories.length === 0 && (
                                <p className="text-red-400 text-xs mt-1" role="alert">Please select at least one category.</p>
                            )}
                        </div>

                        <div className="flex items-center">
                            <input
                                type="checkbox"
                                id="feePaid"
                                checked={feePaid}
                                onChange={(e) => setFeePaid(e.target.checked)}
                                className="form-checkbox h-4 w-4 text-sky-600 bg-slate-700 border-slate-600 rounded focus:ring-sky-500"
                                aria-label="Fee Paid"
                            />
                            <label htmlFor="feePaid" className="ml-2 text-slate-200 text-sm">Fee Paid</label>
                        </div>

                        <div className="flex space-x-2">
                            <button
                                type="submit"
                                className="flex-1 bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors"
                                aria-label={editPlayerId ? 'Update Player' : 'Add Player'}
                            >
                                {editPlayerId ? 'Update Player' : 'Add Player'}
                            </button>
                            {editPlayerId && (
                                <button
                                    type="button"
                                    onClick={resetForm}
                                    className="flex-1 bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline transition-colors"
                                    aria-label="Cancel Edit"
                                >
                                    Cancel Edit
                                </button>
                            )}
                        </div>
                    </form>

                    <div className="mb-6">
                        <label htmlFor="csvUpload" className="block text-slate-300 text-sm font-bold mb-2">
                            Upload Players via CSV
                        </label>
                        <input
                            type="file"
                            id="csvUpload"
                            accept=".csv"
                            onChange={handleCsvUpload}
                            ref={csvFileInputRef}
                            className="block w-full text-sm text-slate-400
                                file:mr-4 file:py-2 file:px-4
                                file:rounded-lg file:border-0
                                file:text-sm file:font-semibold
                                file:bg-sky-500 file:text-white
                                hover:file:bg-sky-600
                                bg-slate-700 rounded-lg cursor-pointer transition-colors"
                            aria-label="Upload Players CSV"
                        />
                        <p className="text-xs text-slate-500 mt-2">Expected CSV headers: "Name", "MobileNumber", "Categories", "Paid(Y/N)". Category values like "40" or "40+" will map to "40+". Only adds new players. Players can be manually edited to add a second category if applicable.</p>
                    </div>

                    <div className="flex justify-end mb-4">
                        <button
                            onClick={handleExportPlayersToCsv}
                            className="bg-slate-600 hover:bg-slate-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                            disabled={players.length === 0}
                            aria-label="Export Players to CSV"
                        >
                            Export Players to CSV
                        </button>
                    </div>

                    <h4 className="text-lg font-semibold text-slate-200 mb-3">Registered Players</h4>
                    {Object.keys(groupedPlayers).length === 0 ? (
                        <p className="text-slate-400">No players registered yet.</p>
                    ) : (
                        <div className="overflow-x-auto rounded-lg shadow">
                            <table className="min-w-full divide-y divide-slate-700" aria-label="Registered Players Table">
                                <thead className="bg-slate-900">
                                    <tr>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                            Mobile Number
                                        </th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                            Player Name(s)
                                        </th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                            Categories
                                        </th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                            Fee Paid
                                        </th>
                                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                            Actions
                                        </th>
                                    </tr>
                                </thead>
                                <tbody className="bg-slate-800 divide-y divide-slate-700">
                                    {Object.entries(groupedPlayers).map(([mobile, playersArr]) => (
                                        <tr key={mobile} className="hover:bg-slate-700">
                                            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-200">
                                                {mobile}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-slate-300">
                                                {playersArr.map(p => p.name).join(', ')}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-slate-300">
                                                {playersArr.map(p => p.categories.join(' & ')).join('; ')}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-slate-300">
                                                {playersArr.every(p => p.feePaid) ? 'Yes' : 'No'}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                                                {playersArr.map(player => (
                                                    <div key={player.id} className="flex gap-2 mb-1 last:mb-0 justify-end">
                                                        <button
                                                            onClick={() => handleEdit(player)}
                                                            className="text-indigo-400 hover:text-indigo-300 text-xs"
                                                            aria-label={`Edit ${player.name}`}
                                                        >
                                                            Edit
                                                        </button>
                                                        <button
                                                            onClick={() => onDeletePlayer(player.id)}
                                                            className="text-red-400 hover:text-red-300 text-xs ml-2"
                                                            aria-label={`Delete ${player.name}`}
                                                        >
                                                            Delete
                                                        </button>
                                                    </div>
                                                ))}
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    )}
                </div>
            );
        };

        const FixtureManagement = ({ players, tournamentSettings, fixtures, onGenerateFixtures, onUpdateScore, onUploadCustomFixtures }) => {
            const [selectedCategory, setSelectedCategory] = useState(tournamentSettings.categories[0] || null);
            const [selectedType, setSelectedType] = useState(tournamentSettings.types[0] || null);
            const customFixtureFileInputRef = useRef(null);

            useEffect(() => {
                if (tournamentSettings.categories.length > 0 && (!selectedCategory || !tournamentSettings.categories.includes(selectedCategory))) {
                    setSelectedCategory(tournamentSettings.categories[0]);
                } else if (tournamentSettings.categories.length === 0) {
                    setSelectedCategory(null);
                }
                if (tournamentSettings.types.length > 0 && (!selectedType || !tournamentSettings.types.includes(selectedType))) {
                    setSelectedType(tournamentSettings.types[0]);
                } else if (tournamentSettings.types.length === 0) {
                    setSelectedType(null);
                }
            }, [tournamentSettings, selectedCategory, selectedType]);

            const getPlayerName = useCallback((playerId) => {
                const player = players.find(p => p.id === playerId);
                return player ? player.name : `Unknown Player (${playerId.substring(0,4)})`;
            }, [players]);

            const handleCustomFixtureUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const jsonString = event.target.result;
                            const customFixtures = JSON.parse(jsonString);
                            // Basic validation for custom fixtures structure
                            if (Array.isArray(customFixtures) && customFixtures.every(f => f.category && f.tournamentType && Array.isArray(f.groups) && Array.isArray(f.matches))) {
                                onUploadCustomFixtures(customFixtures);
                                alert('Custom fixtures uploaded successfully!');
                            } else {
                                alert('Invalid custom fixture JSON format. Please ensure it matches the expected structure: Array of { category, tournamentType, groups: [], matches: [] }');
                            }
                        } catch (error) {
                            alert('Error parsing custom fixture JSON: ' + error.message);
                        } finally {
                            if (customFixtureFileInputRef.current) {
                                customFixtureFileInputRef.current.value = '';
                            }
                        }
                    };
                    reader.readAsText(file);
                }
            };

            const currentCategoryFixtures = fixtures.filter(f =>
                f.category === selectedCategory && f.tournamentType === selectedType
            );

            return (
                <div className="bg-slate-800 p-6 rounded-lg shadow-lg mb-6">
                    <h3 className="text-xl font-semibold text-slate-100 mb-4">Fixture & Score Management</h3>

                    <div className="flex flex-col sm:flex-row gap-4 mb-4">
                        <div className="flex-1">
                            <label htmlFor="selectCategory" className="block text-slate-300 text-sm font-bold mb-2">Select Category</label>
                            <select
                                id="selectCategory"
                                value={selectedCategory || ''}
                                onChange={(e) => setSelectedCategory(e.target.value)}
                                className="block w-full py-2 px-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 text-white sm:text-sm"
                                aria-label="Select Category for Fixtures"
                                disabled={tournamentSettings.categories.length === 0}
                            >
                                {tournamentSettings.categories.length === 0 ? (
                                    <option value="">No categories defined</option>
                                ) : (
                                    tournamentSettings.categories.map(cat => (
                                        <option key={cat} value={cat}>{cat}</option>
                                    ))
                                )}
                            </select>
                        </div>
                        <div className="flex-1">
                            <label htmlFor="selectType" className="block text-slate-300 text-sm font-bold mb-2">Select Type</label>
                            <select
                                id="selectType"
                                value={selectedType || ''}
                                onChange={(e) => setSelectedType(e.target.value)}
                                className="block w-full py-2 px-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 text-white sm:text-sm"
                                aria-label="Select Tournament Type for Fixtures"
                                disabled={tournamentSettings.types.length === 0}
                            >
                                {tournamentSettings.types.length === 0 ? (
                                    <option value="">No types defined</option>
                                ) : (
                                    tournamentSettings.types.map(type => (
                                        <option key={type} value={type}>{type}</option>
                                    ))
                                )}
                            </select>
                        </div>
                    </div>


                    <div className="flex flex-col md:flex-row gap-4 mb-6">
                        <button
                            onClick={() => onGenerateFixtures(selectedCategory, selectedType)}
                            className="flex-1 bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                            disabled={!selectedCategory || !selectedType || players.length === 0}
                            aria-label="Generate Fixtures"
                        >
                            Generate Fixtures
                        </button>
                        <div className="flex-1">
                            <label htmlFor="customFixtureUpload" className="sr-only">Upload Custom Fixtures</label>
                            <input
                                type="file"
                                id="customFixtureUpload"
                                accept=".json"
                                onChange={handleCustomFixtureUpload}
                                ref={customFixtureFileInputRef}
                                className="block w-full text-sm text-slate-400
                                    file:mr-4 file:py-2 file:px-4
                                    file:rounded-lg file:border-0
                                    file:text-sm file:font-semibold
                                    file:bg-slate-600 file:text-white
                                    hover:file:bg-slate-700
                                    bg-slate-700 rounded-lg cursor-pointer transition-colors"
                                aria-label="Upload Custom Fixtures JSON"
                            />
                            <p className="text-xs text-slate-500 mt-1">Upload JSON for custom fixtures for selected category/type</p>
                        </div>
                    </div>

                    {(tournamentSettings.categories.length === 0 || tournamentSettings.types.length === 0) ? (
                        <p className="text-red-400 italic">Please define tournament types and categories in settings before managing fixtures.</p>
                    ) : players.length === 0 ? (
                        <p className="text-red-400 italic">Please add players before generating fixtures.</p>
                    ) : currentCategoryFixtures.length === 0 ? (
                        <p className="text-slate-400">No fixtures generated or uploaded for this category/type yet. Click 'Generate Fixtures' or 'Upload Custom Fixtures'.</p>
                    ) : (
                        currentCategoryFixtures.map(catFix => (
                            <div key={`${catFix.category}-${catFix.tournamentType}`} className="space-y-6">
                                <h4 className="text-lg font-semibold text-slate-200 mb-2">{catFix.category} - {catFix.tournamentType} Fixtures</h4>
                                {catFix.groups.map(group => (
                                    <div key={group.id} className="bg-slate-700 p-4 rounded-lg">
                                        <h5 className="font-bold text-slate-100 mb-3">{group.name}</h5>
                                        <p className="text-sm text-slate-300 mb-4">Players: {group.playerIds.map(getPlayerName).join(', ')}</p>
                                        <div className="overflow-x-auto">
                                            <table className="min-w-full divide-y divide-slate-600" aria-label={`Matches for ${group.name}`}>
                                                <thead className="bg-slate-800">
                                                    <tr>
                                                        <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                            Match
                                                        </th>
                                                        <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                            Player 1
                                                        </th>
                                                        <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                            Player 2
                                                        </th>
                                                        <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                            Score (P1 - P2)
                                                        </th>
                                                        <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                            Status
                                                        </th>
                                                        <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                            Actions
                                                        </th>
                                                    </tr>
                                                </thead>
                                                <tbody className="bg-slate-700 divide-y divide-slate-600">
                                                    {catFix.matches
                                                        .filter(match =>
                                                            group.playerIds.includes(match.player1Id) && group.playerIds.includes(match.player2Id)
                                                        )
                                                        .map(match => (
                                                            <tr key={match.id} className="hover:bg-slate-600">
                                                                <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-200">
                                                                    {getPlayerName(match.player1Id)} vs {getPlayerName(match.player2Id)}
                                                                </td>
                                                                <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-300">
                                                                    {getPlayerName(match.player1Id)}
                                                                </td>
                                                                <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-300">
                                                                    {getPlayerName(match.player2Id)}
                                                                </td>
                                                                <td className="px-4 py-3 whitespace-nowrap text-sm">
                                                                    <div className="flex items-center space-x-2">
                                                                        <input
                                                                            type="number"
                                                                            className="w-16 bg-slate-600 text-slate-200 text-center rounded-md text-sm py-1 px-1 focus:ring-sky-500 focus:border-sky-500"
                                                                            value={match.score1 === null ? '' : match.score1}
                                                                            onChange={(e) => onUpdateScore(match.id, parseInt(e.target.value) || 0, match.score2, 'score1')}
                                                                            aria-label={`Score for ${getPlayerName(match.player1Id)}`}
                                                                        />
                                                                        <span>-</span>
                                                                        <input
                                                                            type="number"
                                                                            className="w-16 bg-slate-600 text-slate-200 text-center rounded-md text-sm py-1 px-1 focus:ring-sky-500 focus:border-sky-500"
                                                                            value={match.score2 === null ? '' : match.score2}
                                                                            onChange={(e) => onUpdateScore(match.id, match.score1, parseInt(e.target.value) || 0, 'score2')}
                                                                            aria-label={`Score for ${getPlayerName(match.player2Id)}`}
                                                                        />
                                                                    </div>
                                                                </td>
                                                                <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-300 capitalize">
                                                                    {match.status}
                                                                </td>
                                                                <td className="px-4 py-3 whitespace-nowrap text-right text-sm font-medium">
                                                                    <select
                                                                        value={match.status}
                                                                        onChange={(e) => onUpdateScore(match.id, match.score1, match.score2, 'status', e.target.value)}
                                                                        className="bg-slate-600 text-slate-200 rounded-md text-sm py-1 px-2 focus:ring-sky-500 focus:border-sky-500"
                                                                        aria-label={`Update status for match ${getPlayerName(match.player1Id)} vs ${getPlayerName(match.player2Id)}`}
                                                                    >
                                                                        <option value="scheduled">Scheduled</option>
                                                                        <option value="in-progress">In-Progress</option>
                                                                        <option value="completed">Completed</option>
                                                                    </select>
                                                                </td>
                                                            </tr>
                                                        ))}
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        ))
                    )}
                </div>
            );
        };

        const AdminDashboard = ({ tournamentData, setTournamentData, onPublish, isPublishing, setIsPublishing }) => {
            // isPublishing state is now managed by the parent App component

            const saveTournamentSettings = (newSettings) => {
                setTournamentData(prev => ({ ...prev, settings: newSettings }));
            };

            const addPlayer = (newPlayer) => {
                setTournamentData(prev => ({ ...prev, players: [...prev.players, newPlayer] }));
            };

            const addPlayersFromCsv = (newPlayers) => {
                setTournamentData(prev => {
                    // This handles duplicates by mobile number that might occur if CSV contains duplicates or existing players
                    const uniqueNewPlayers = [];
                    const existingMobiles = new Set(prev.players.map(p => p.mobile));
                    
                    newPlayers.forEach(np => {
                        if (!existingMobiles.has(np.mobile)) {
                            uniqueNewPlayers.push(np);
                            existingMobiles.add(np.mobile); // Add to temp set for current batch
                        }
                    });
                    return { ...prev, players: [...prev.players, ...uniqueNewPlayers] };
                });
            };

            const updatePlayer = (updatedPlayer) => {
                setTournamentData(prev => ({
                    ...prev,
                    players: prev.players.map(p => p.id === updatedPlayer.id ? updatedPlayer : p)
                }));
            };

            const deletePlayer = (playerId) => {
                if (window.confirm('Are you sure you want to delete this player? This will also remove them from any generated fixtures.')) {
                    setTournamentData(prev => ({
                        ...prev,
                        players: prev.players.filter(p => p.id !== playerId),
                        // Also remove player from any existing fixtures
                        fixtures: prev.fixtures.map(catFix => ({
                            ...catFix,
                            groups: catFix.groups.map(group => ({
                                ...group,
                                playerIds: group.playerIds.filter(id => id !== playerId)
                            })).filter(group => group.playerIds.length >= 2), // Remove groups that become too small
                            matches: catFix.matches.filter(match => match.player1Id !== playerId && match.player2Id !== playerId)
                        })).filter(catFix => catFix.groups.length > 0) // Remove categories without any valid groups
                    }));
                    alert('Player deleted successfully!');
                }
            };

            const generateFixtures = (category, type) => {
                if (!category || !type) {
                    alert('Please select a category and tournament type to generate fixtures.');
                    return;
                }

                const playersForCategoryAndType = tournamentData.players.filter(p =>
                    p.categories.includes(category)
                );

                // Minimum 4 players to form a group of 4-6
                const MIN_GROUP_SIZE = 4; 
                const MAX_GROUP_SIZE = 6;

                if (playersForCategoryAndType.length < MIN_GROUP_SIZE) { 
                    alert(`Not enough players for category "${category}" and type "${type}". Need at least ${MIN_GROUP_SIZE} players. Found: ${playersForCategoryAndType.length}`);
                    return;
                }
                
                const playerIdsForGrouping = playersForCategoryAndType.map(p => p.id);

                const grouped = groupPlayersRandomly({[category]: {[type]: playerIdsForGrouping}}, MIN_GROUP_SIZE, MAX_GROUP_SIZE);
                const groupsForCurrentCategoryType = grouped[category][type];

                if (!groupsForCurrentCategoryType || groupsForCurrentCategoryType.length === 0) {
                     alert(`Could not form valid groups for category "${category}" and type "${type}" with ${playersForCategoryAndType.length} players (min: ${MIN_GROUP_SIZE}, max: ${MAX_GROUP_SIZE}). Consider adjusting player count.`);
                     return;
                }

                const matchesForCategoryType = [];
                groupsForCurrentCategoryType.forEach(group => {
                    const groupMatches = generateRoundRobinMatches(group.playerIds, category, type, group.name);
                    matchesForCategoryType.push(...groupMatches);
                });

                const newCategoryFixture = {
                    category: category,
                    tournamentType: type,
                    groups: groupsForCurrentCategoryType,
                    matches: matchesForCategoryType,
                };

                // Merge with existing fixtures, update or add.
                setTournamentData(prev => {
                    const existingFixtures = prev.fixtures.filter(f => !(f.category === category && f.tournamentType === type));
                    return { ...prev, fixtures: [...existingFixtures, newCategoryFixture] };
                });
                alert('Fixtures generated successfully! Now, click "Publish Tournament to Players" at the bottom to make them visible!');
            };

            const uploadCustomFixtures = (customFixtures) => {
                 setTournamentData(prev => {
                    // Filter out existing fixtures for the same category/type as in customFixtures
                    const filteredExistingFixtures = prev.fixtures.filter(existingF =>
                        !customFixtures.some(customF =>
                            customF.category === existingF.category && customF.tournamentType === existingF.tournamentType
                        )
                    );
                    return { ...prev, fixtures: [...filteredExistingFixtures, ...customFixtures] };
                });
            };


            const updateScore = (matchId, score1, score2, fieldToUpdate, statusValue = null) => {
                setTournamentData(prev => ({
                    ...prev,
                    fixtures: prev.fixtures.map(catFix => ({
                        ...catFix,
                        matches: catFix.matches.map(match => {
                            if (match.id === matchId) {
                                return {
                                    ...match,
                                    score1: fieldToUpdate === 'score1' ? score1 : match.score1,
                                    score2: fieldToUpdate === 'score2' ? score2 : match.score2,
                                    status: fieldToUpdate === 'status' ? statusValue : match.status,
                                };
                            }
                            return match;
                        })
                    }))
                }));
            };

            const handlePublishClick = async () => {
                // Removed window.confirm as per previous user request. Publish directly.
                console.log('AdminDashboard: handlePublishClick - Initiating publish process.');
                setIsPublishing(true); // Start loading state
                try {
                    await new Promise(resolve => setTimeout(resolve, 500)); // Simulate API call or heavy operation
                    onPublish(); // This updates tournamentData.isPublished in App
                    alert('Tournament successfully published to players!'); // Success message after publish
                } catch (error) {
                    console.error("Failed to publish tournament:", error);
                    alert("Failed to publish tournament. Please try again.");
                } finally {
                    setIsPublishing(false); // End loading state
                }
            };

            // Determine if publishing is allowed
            const canPublish = tournamentData.settings.name.trim() !== '' &&
                               tournamentData.settings.types.length > 0 &&
                               tournamentData.settings.categories.length > 0 &&
                               tournamentData.players.length > 0 &&
                               tournamentData.fixtures.length > 0;

            const publishDisabledReason = !tournamentData.settings.name.trim() ? 'Complete tournament name in settings.' :
                                          tournamentData.settings.types.length === 0 ? 'Select tournament types in settings.' :
                                          tournamentData.settings.categories.length === 0 ? 'Select player categories in settings.' :
                                          tournamentData.players.length === 0 ? 'Add players.' :
                                          tournamentData.fixtures.length === 0 ? 'Generate or upload fixtures.' :
                                          '';

            return (
                <div className="space-y-8">
                    <TournamentSetup settings={tournamentData.settings} onSaveSettings={saveTournamentSettings} />
                    <PlayerManagement
                        players={tournamentData.players}
                        tournamentSettings={tournamentData.settings}
                        onAddPlayer={addPlayer}
                        onUpdatePlayer={updatePlayer}
                        onDeletePlayer={deletePlayer}
                        onAddPlayersFromCsv={addPlayersFromCsv}
                    />
                    <FixtureManagement
                        players={tournamentData.players}
                        tournamentSettings={tournamentData.settings}
                        fixtures={tournamentData.fixtures}
                        onGenerateFixtures={generateFixtures}
                        onUpdateScore={updateScore}
                        onUploadCustomFixtures={uploadCustomFixtures}
                    />
                    <button
                        onClick={handlePublishClick}
                        className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                        aria-label="Publish Tournament"
                        disabled={!canPublish || isPublishing}
                    >
                        {isPublishing ? 'Publishing...' : 'Publish Tournament to Players'}
                    </button>
                    {!canPublish && publishDisabledReason && (
                        <p className="text-red-400 text-sm text-center" role="status">
                            Cannot publish: {publishDisabledReason}
                        </p>
                    )}
                </div>
            );
        };

        const PlayerView = () => { // No longer receives tournamentData as a prop, fetches directly
            const [localTournamentData, setLocalTournamentData] = useState(null);
            const [selectedFilterCategory, setSelectedFilterCategory] = useState('All'); // New state for players filtering
            const [selectedFixtureFilterCategory, setSelectedFixtureFilterCategory] = useState('All'); // New state for fixtures filtering

            // Define getPlayerName here, unconditionally, before any early returns
            const getPlayerName = useCallback((playerId) => {
                // Safely access players array even if localTournamentData is null or players is undefined
                const playersArray = localTournamentData?.players || [];
                const player = playersArray.find(p => p.id === playerId);
                return player ? player.name : `Unknown Player (${playerId ? playerId.substring(0,4) : 'N/A'})`;
            }, [localTournamentData]); // Depend on the entire localTournamentData object

            const fetchTournamentData = useCallback(() => {
                const storedData = getLocalStorage(LS_TOURNAMENT_DATA, null);
                console.log('PlayerView: Fetched from localStorage. isPublished:', storedData?.isPublished, 'Settings Name:', storedData?.settings?.name, 'Full Data:', storedData);
                setLocalTournamentData(storedData);
            }, []);

            useEffect(() => {
                fetchTournamentData();
            }, [fetchTournamentData]); // Fetch once on mount

            // Re-fetch if localStorage changes (e.g., admin publishes)
            useEffect(() => {
                const handleStorageChange = (event) => {
                    // Only react to changes in our specific key or if event.key is null (change in current tab/same origin)
                    if (event.key === LS_TOURNAMENT_DATA || event.key === null) {
                        console.log('PlayerView: localStorage "storage" event fired. Re-fetching data.');
                        fetchTournamentData();
                    }
                };
                window.addEventListener('storage', handleStorageChange);
                return () => window.removeEventListener('storage', handleStorageChange);
            }, [fetchTournamentData]);


            if (!localTournamentData || !localTournamentData.settings || !localTournamentData.settings.name) {
                // No tournament data or basic settings are missing
                return (
                    <div className="min-h-[calc(100vh-80px)] flex flex-col items-center justify-center text-slate-400">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 mb-4 text-slate-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1}>
                          <path strokeLinecap="round" strokeLinejoin="round" d="M9.75 3.104l-2.286 9.144a3.75 3.75 0 003.75 4.498h1.5A3.75 3.75 0 0016.5 12.25l-2.286-9.144a3.75 3.75 0 00-4.464 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" d="M12 21a9.002 9.002 0 008.13-5.253M3.87 15.747A9.002 9.002 0 0012 21" />
                        </svg>
                        <h2 className="text-2xl font-bold mb-2">No Tournament Data Available</h2>
                        <p className="text-lg">An administrator needs to set up and publish a tournament.</p>
                    </div>
                );
            }

            if (!localTournamentData.isPublished) {
                // Tournament data exists, but it's not published
                 return (
                    <div className="min-h-[calc(100vh-80px)] flex flex-col items-center justify-center text-slate-400">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-16 w-16 mb-4 text-slate-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1}>
                          <path strokeLinecap="round" strokeLinejoin="round" d="M9.75 3.104l-2.286 9.144a3.75 3.75 0 003.75 4.498h1.5A3.75 3.75 0 0016.5 12.25l-2.286-9.144a3.75 3.75 0 00-4.464 0z" />
                          <path strokeLinecap="round" strokeLinejoin="round" d="M12 21a9.002 9.002 0 008.13-5.253M3.87 15.747A9.002 9.002 0 0012 21" />
                        </svg>
                        <h2 className="text-2xl font-bold mb-2">Tournament In Draft Mode</h2>
                        <p className="text-lg">This tournament has not yet been published by the administrator.</p>
                        <p className="text-lg">Check back later for tournament details and fixtures!</p>
                    </div>
                );
            }

            // Filter players based on selectedFilterCategory
            const filteredPlayers = selectedFilterCategory === 'All'
                ? localTournamentData.players
                : localTournamentData.players.filter(player => player.categories.includes(selectedFilterCategory));


            const groupedPlayers = filteredPlayers.reduce((acc, player) => {
                if (!acc[player.mobile]) {
                    acc[player.mobile] = [];
                }
                acc[player.mobile].push(player);
                return acc;
            }, {});

            // Filter fixtures based on selectedFixtureFilterCategory
            const filteredFixtures = selectedFixtureFilterCategory === 'All'
                ? localTournamentData.fixtures
                : localTournamentData.fixtures.filter(catFix => catFix.category === selectedFixtureFilterCategory);


            return (
                <div className="container mx-auto p-4 sm:p-6 lg:p-8 space-y-8">
                    <h2 className="text-4xl font-bold text-sky-400 mb-6 text-center">
                        {localTournamentData.settings.name}
                    </h2>

                    <div className="bg-slate-800 p-6 rounded-lg shadow-lg">
                        <h3 className="text-2xl font-semibold text-slate-100 mb-4">Tournament Details</h3>
                        <p className="text-slate-300 mb-2">
                            <span className="font-medium text-slate-200">Types:</span> {localTournamentData.settings.types.join(', ')}
                        </p>
                        <p className="text-slate-300">
                            <span className="font-medium text-slate-200">Categories:</span> {localTournamentData.settings.categories.join(', ')}
                        </p>
                    </div>

                    <div className="bg-slate-800 p-6 rounded-lg shadow-lg">
                        <div className="flex justify-between items-center mb-4">
                            <h3 className="2xl font-semibold text-slate-100">Registered Players</h3>
                            {localTournamentData.settings.categories.length > 0 && (
                                <div className="flex items-center space-x-2">
                                    <label htmlFor="categoryFilter" className="text-slate-300 text-sm">Filter by Category:</label>
                                    <select
                                        id="categoryFilter"
                                        value={selectedFilterCategory}
                                        onChange={(e) => setSelectedFilterCategory(e.target.value)}
                                        className="py-2 px-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 text-white sm:text-sm"
                                        aria-label="Filter players by category"
                                    >
                                        <option value="All">All Categories</option>
                                        {localTournamentData.settings.categories.map(category => (
                                            <option key={category} value={category}>{category}</option>
                                        ))}
                                    </select>
                                </div>
                            )}
                        </div>
                        {Object.keys(groupedPlayers).length === 0 ? (
                            <p className="text-slate-400">No players registered yet or no players match the selected category.</p>
                        ) : (
                            <div className="overflow-x-auto rounded-lg shadow">
                                <table className="min-w-full divide-y divide-slate-700" aria-label="Registered Players Table">
                                    <thead className="bg-slate-900">
                                        <tr>
                                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                Mobile Number
                                            </th>
                                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                Player Name(s)
                                            </th>
                                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                Categories
                                            </th>
                                            <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                Fee Paid
                                            </th>
                                        </tr>
                                    </thead>
                                    <tbody className="bg-slate-800 divide-y divide-slate-700">
                                        {Object.entries(groupedPlayers).map(([mobile, playersArr]) => (
                                            <tr key={mobile} className="hover:bg-slate-700">
                                                <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-200">
                                                    {mobile}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-slate-300">
                                                    {playersArr.map(p => p.name).join(', ')}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-slate-300">
                                                    {playersArr.map(p => p.categories.join(' & ')).join('; ')}
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap text-sm text-slate-300">
                                                    {playersArr.every(p => p.feePaid) ? 'Yes' : 'No'}
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </div>

                    <div className="bg-slate-800 p-6 rounded-lg shadow-lg">
                        <div className="flex justify-between items-center mb-4">
                            <h3 className="2xl font-semibold text-slate-100">Match Fixtures</h3>
                            {localTournamentData.settings.categories.length > 0 && (
                                <div className="flex items-center space-x-2">
                                    <label htmlFor="fixtureCategoryFilter" className="text-slate-300 text-sm">Filter by Category:</label>
                                    <select
                                        id="fixtureCategoryFilter"
                                        value={selectedFixtureFilterCategory}
                                        onChange={(e) => setSelectedFixtureFilterCategory(e.target.value)}
                                        className="py-2 px-3 bg-slate-700 border border-slate-600 rounded-lg shadow-sm focus:outline-none focus:ring-sky-500 focus:border-sky-500 text-white sm:text-sm"
                                        aria-label="Filter fixtures by category"
                                    >
                                        <option value="All">All Categories</option>
                                        {localTournamentData.settings.categories.map(category => (
                                            <option key={category} value={category}>{category}</option>
                                        ))}
                                    </select>
                                </div>
                            )}
                        </div>

                        {filteredFixtures.length === 0 ? (
                            <p className="text-slate-400">No fixtures published yet or no fixtures match the selected category.</p>
                        ) : (
                            <div className="space-y-6">
                                {filteredFixtures.map(catFix => (
                                    <div key={`${catFix.category}-${catFix.tournamentType}`} className="bg-slate-700 p-4 rounded-lg">
                                        <h4 className="text-xl font-semibold text-slate-100 mb-3">{catFix.category} - {catFix.tournamentType}</h4>
                                        {catFix.groups.map(group => (
                                            <div key={group.id} className="mb-4">
                                                <h5 className="font-bold text-slate-200 mb-2">{group.name}</h5>
                                                <p className="text-sm text-slate-300 mb-3">Players: {group.playerIds.map(getPlayerName).join(', ')}</p>
                                                <div className="overflow-x-auto">
                                                    <table className="min-w-full divide-y divide-slate-600" aria-label={`Matches for ${group.name}`}>
                                                        <thead className="bg-slate-800">
                                                            <tr>
                                                                <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                                    Match
                                                                </th>
                                                                <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                                    Player 1
                                                                </th>
                                                                <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                                    Player 2
                                                                </th>
                                                                <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                                    Score
                                                                </th>
                                                                <th scope="col" className="px-4 py-2 text-left text-xs font-medium text-slate-400 uppercase tracking-wider">
                                                                    Status
                                                                </th>
                                                            </tr>
                                                        </thead>
                                                        <tbody className="bg-slate-700 divide-y divide-slate-600">
                                                            {catFix.matches
                                                                .filter(match =>
                                                                    group.playerIds.includes(match.player1Id) && group.playerIds.includes(match.player2Id)
                                                                )
                                                                .map(match => {
                                                                    const statusColor = match.status === 'completed' ? 'bg-green-600' : match.status === 'in-progress' ? 'bg-sky-600' : 'bg-slate-600';
                                                                    const statusText = match.status.charAt(0).toUpperCase() + match.status.slice(1);
                                                                    const isCompleted = match.status === 'completed';

                                                                    return (
                                                                        <tr key={match.id} className={`hover:bg-slate-600 ${isCompleted ? 'border-l-4 border-green-500' : ''}`}>
                                                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-200">
                                                                                {getPlayerName(match.player1Id)} vs {getPlayerName(match.player2Id)}
                                                                            </td>
                                                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-300">
                                                                                {getPlayerName(match.player1Id)}
                                                                            </td>
                                                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-slate-300">
                                                                                {getPlayerName(match.player2Id)}
                                                                            </td>
                                                                            <td className="px-4 py-3 whitespace-nowrap text-sm">
                                                                                {isCompleted && match.score1 !== null && match.score2 !== null ? (
                                                                                    <span className="font-bold text-green-300">{match.score1} - {match.score2}</span>
                                                                                ) : (
                                                                                    'N/A'
                                                                                )}
                                                                            </td>
                                                                            <td className="px-4 py-3 whitespace-nowrap text-sm">
                                                                                <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${statusColor} text-white`}>
                                                                                    {statusText}
                                                                                    {isCompleted && (
                                                                                        <svg className="ml-1 h-3 w-3" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                                                                                            <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                                                                                        </svg>
                                                                                    )}
                                                                                </span>
                                                                            </td>
                                                                        </tr>
                                                                    );
                                                                })}
                                                        </tbody>
                                                    </table>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            );
        };


        // --- Main Application Component ---

        const App = () => {
            const [isAdminLoggedIn, setIsAdminLoggedIn] = useState(getLocalStorage(LS_ADMIN_LOGGED_IN, false));
            const [viewMode, setViewMode] = useState(isAdminLoggedIn ? 'admin' : 'player'); // 'admin-login', 'admin', 'player'
            const [isPublishing, setIsPublishing] = useState(false); // Lifted state

            const [tournamentData, setTournamentData] = useState(() => {
                const storedData = getLocalStorage(LS_TOURNAMENT_DATA, null);
                // Ensure isPublished is always present and default settings are consistent
                const defaultTournamentData = {
                    settings: {
                        name: 'New Tournament',
                        types: [TournamentType.MEN_SINGLES],
                        categories: [PlayerCategory.OPEN],
                    },
                    players: [],
                    fixtures: [],
                    isPublished: false,
                };
                if (storedData) {
                    return {
                        ...defaultTournamentData, // Ensure default structure if parts are missing
                        ...storedData,
                        settings: { ...defaultTournamentData.settings, ...storedData.settings }, // Merge settings
                        isPublished: storedData.hasOwnProperty('isPublished') ? storedData.isPublished : false // Ensure flag
                    };
                }
                return defaultTournamentData;
            });

            // Persist admin login state
            useEffect(() => {
                setLocalStorage(LS_ADMIN_LOGGED_IN, isAdminLoggedIn);
            }, [isAdminLoggedIn]);

            // Persist tournament data
            useEffect(() => {
                console.log('App: useEffect - Saving tournamentData to localStorage. isPublished:', tournamentData.isPublished, 'Data:', tournamentData);
                setLocalStorage(LS_TOURNAMENT_DATA, tournamentData);
            }, [tournamentData]);

            const handleAdminLogin = () => {
                setIsAdminLoggedIn(true);
                setViewMode('admin');
            };

            const handleAdminLogout = () => {
                setIsAdminLoggedIn(false);
                setViewMode('admin-login');
            };

            const handlePublishTournament = () => {
                console.log('App: handlePublishTournament - START. Current tournamentData:', JSON.stringify(tournamentData));

                // Perform checks before publishing (these should ideally match `canPublish` in AdminDashboard)
                if (tournamentData.settings.name.trim() === '') {
                    alert('Publish failed: Please complete tournament name in settings.');
                    return;
                }
                if (tournamentData.settings.types.length === 0) {
                    alert('Publish failed: Please select at least one tournament type in settings.');
                    return;
                }
                if (tournamentData.settings.categories.length === 0) {
                    alert('Publish failed: Please select at least one player category in settings.');
                    return;
                }
                if (tournamentData.players.length === 0) {
                    alert('Publish failed: Please add players.');
                    return;
                }
                if (tournamentData.fixtures.length === 0) {
                    alert('Publish failed: Please generate or upload fixtures.');
                    return;
                }
                
                const newState = { ...tournamentData, isPublished: true };
                setTournamentData(newState); // Update component state, which will trigger useEffect for persistence
                console.log('App: handlePublishTournament - END. newState.isPublished:', newState.isPublished, 'TournamentData after setTournamentData:', JSON.stringify(newState));
            };

            // Derived publish status for AppHeader
            const publishStatus = isPublishing
                ? 'Publishing...'
                : tournamentData.isPublished
                    ? 'Published'
                    : 'Draft';

            return (
                <div className="min-h-screen bg-slate-900 text-slate-200">
                    <AppHeader
                        isAdmin={isAdminLoggedIn}
                        onLogout={handleAdminLogout}
                        viewMode={viewMode}
                        setViewMode={setViewMode}
                        publishStatus={publishStatus} // Pass derived status
                    />
                    <main className="container mx-auto p-4 sm:p-6 lg:p-8">
                        {viewMode === 'admin-login' && !isAdminLoggedIn && (
                            <AdminLogin onLogin={handleAdminLogin} />
                        )}
                        {viewMode === 'admin' && isAdminLoggedIn && (
                            <AdminDashboard
                                tournamentData={tournamentData}
                                setTournamentData={setTournamentData}
                                onPublish={handlePublishTournament}
                                isPublishing={isPublishing} // Pass lifted state
                                setIsPublishing={setIsPublishing} // Pass setter for lifted state
                            />
                        )}
                        {viewMode === 'player' && (
                            <PlayerView />
                        )}
                    </main>
                </div>
            );
        };

        // --- Use modern createRoot API ---
        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>